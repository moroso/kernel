//sends message to file server
use prelude::string::*;
use prelude::syslib::*;
use prelude::shared::*;
use prelude::thrlib::*;
use prelude::rt_abort;
use prelude::shared::ipc_defs::*;
use prelude::utils::asm::*;

const NAME_MAX: u32 = 400;
const SERVER_ID: u32 = 5;

struct file_message {
    name: u8[NAME_MAX],
    request_type: u32,
    buffer_len: u32,
}

static file_server_active: bool = true;
static threads_dormant: u32 = 0; // number of threads needing wakeup

/*** server code ***/

/* code that each of the servers run, which processes requests.  We assume our
 * clients are trustworthy enough to give us clean messages (but we don't need
 * to trust */
fn run_server(mb_arg: *u8) {

    /*** setup ***/
    let mb = mb_arg as i32;
    assert!(mb >= 0);
    let status: i32 = -1;

    let args: ipc_args;
    args.dest_id = mb as u32;
    args.long_dest.len = 0;
    args.short_dest.len = sizeof(i32);
    args.short_dest.addr = &status as *u8; 
    args.timeout = -1;
   
    assert!(ipc_recv(&args) >= 0);
    if (status < 0) {
        printf!("err %d\n", get_tid());
        file_server_active = false;
        abscond(-1);
    }
    printf!("thread %d waiting for wakeup\n", get_tid());
    atomic_add(&threads_dormant, -1);
    while (threads_dormant > 0) {
        yield(-1);
    }
    assert!(threads_dormant >= 0);
   
    printf!("thread %d running server\n", get_tid());

    /*** active server code ***/
    let message: file_message;
    args.short_dest.len = sizeof(file_message);
    args.short_dest.addr = &message as *u8;
    while(file_server_active) {
        if (ipc_recv(&args) >= 0) {
            // if message does no look like one, return an error
            if (args.short_dest.len != sizeof(file_message)) {
                status = -1;
            } else {

                status = get_tid() as i32;
                printf!("error\n");
            }
            ipc_reply(null, 0, &status as *u32, sizeof(i32));

        }     
    }
    printf!("thread %d exiting server\n", get_tid());
    abscond(0);
}

/* file_server_init: creates a file server with specified number of threads.
 * spins up a new process with a mailbox; all threads execute server_run.  if a
 * valid mailbox descriptor desc is specified, new server sends a message to the
 * mailbox with its descriptor.  Returns with error if threads or mailbox fail
 * to init
 *
 * - num_threads: number of threads for new server.  All threads exit and server
 *   sends failure to desc if all threads cannot be created
 * - desc: a descriptor for the mailbox to which the server sends its status.
 *   Must be a valid descriptor for the invoking thread.
 *   On error, it sends an error code.  Otherwise, it forwards a descriptor to
 *   the mailbox and sends the descriptor in a short message, meaning the
 *   server is ready to take requests
 *
 * Returns error if repl fails, 0 otherwise.  
 *
 * NOTE catching further errors requires sending a descriptor and waiting on
 * that mailbox for a status.
 * NOTE if a valid descriptor desc is given but no thread ever waits on desc,
 * server can fail to properly init and be blocked forever (if async send fails)
 */
fn file_server_init(num_threads: u32, desc: i32) -> i32 {
    file_server_active = false;
    let status: i32 = 0;
    /* for sending a status to a descriptor */
    let args: ipc_args;
    args.dest_id = desc as u32;
    args.long_src.len = 0;
    args.short_src.len = sizeof(i32);
    args.short_src.addr = &status as *u8;
    args.timeout = -1;
    args.options = OPTION_ASYNC;

    /* creating file server proc */
    let ret = repl();
    if (ret < 0) {
        return -1;
    }
    if (ret == 0) {
        /* file server creates own mailbox */
        let mb: i32 = -1;
        if ((mb = mailbox_new()) < 0) {
            if (desc >= 0) {
                // on error send, error code to descriptor 
                status = -1;
                ipc_send(&args);
            }
            abscond(-1);
        }
        let i: u32;
        // spin up the specified number of threads; quit early if thread
        // creation fails
        for (i = 0; i < num_threads; i+=1) {
            printf!("creating thread %d\n", i);
            if ((ret = thr_create(run_server, mb as *u8)) < 0) {
                // TODO task_vanish or cond var
                status = -2;
                num_threads = i;
                break; 
            } 
        }

        assert!(mb >= 0);
        args.dest_id = mb as u32;
        args.options = OPTION_NO_REPLY;

        if (status >= 0) {
            atomic_add(&threads_dormant, num_threads);
            // we set this before the server is truly active, but it's ok,
            // because nothing will get sent to the mailbox until we end out the
            // descriptor, which happens after the threads wake up
            file_server_active = true;
        }

        // wake up child threads either with success (run server) or error
        // (abscond immediately)
        // do this before waking the proc waiting on desc in case they attempt to wait on our
        // mailbox and ruin everything 
        for (i = 0; i < num_threads; i+=1) {
            printf!("waking up thread %d\n", i);
            assert!(ipc_send(&args) >= 0);
        }

        // wake up thread waiting on given mailbox
        if (desc >= 0) {

            // wait until server is fully active
            while(threads_dormant > 0) {
                yield(-1);
            }

            if (status < 0) {

                args.options = OPTION_ASYNC;
                // if async fails due to memory, send a synchronous message instead
                if (ipc_send(&args) == IPC_ERR_INTERNAL) {
                    args.options = OPTION_NO_REPLY;
                    ipc_send(&args); 
                }
            } else {
                if (mailbox_forward(mb as u32, desc as u32) < 0) {
                    // TODO handle err
                }
            }
        }
        printf!("exiting\n");
        abscond(status);

        assert!(false); // no return
    }

    0
}


/*** client code ***/
/* send a new file name and some data to start the new file.  returns with error
 * if ipc fails, or if the file already exists */
fn create(name: *u8, buffer: *u8, buffer_len: u32) -> i32 {
    if (strnlen(name, NAME_MAX + 1) > NAME_MAX) {
        return -1;
    }
    // TODO sanitize name input
    let message: file_message;
    let status_buffer: u32[5];
    let len = strncpy(&(message.name)[0], name, NAME_MAX);
    assert!(len <= NAME_MAX); 
    let args: ipc_defs::ipc_args;
    args.dest_id = SERVER_ID; 
    args.long_src.addr = buffer;
    // round up
    args.long_src.len = len + (len%4096);
    args.short_src.addr = &message as *u8;
    args.short_src.len = sizeof(file_message);
    args.long_dest.len = 0;
    args.short_dest.addr = &status_buffer[0] as *u8;
    args.short_dest.len = sizeof(u32) * 5;

    0
}
