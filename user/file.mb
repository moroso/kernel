//sends message to file server
use prelude::string::*;
use prelude::syslib::*;
use prelude::shared::*;
use prelude::thrlib::*;
use prelude::rt_abort;
use prelude::shared::ipc_defs::*;

const NAME_MAX: u32 = 400;
const SERVER_ID: u32 = 5;

struct file_message {
    name: u8[NAME_MAX],
    buffer_len: u32,
}

static file_server_active: bool = false;


/*** server code ***/

fn run_server(mb_arg: *u8) {
    let mb = mb_arg as i32;
    assert!(mb >= 0);
    let status: i32 = -1;

    let args: ipc_args;
    args.dest_id = mb as u32;
    args.long_dest.len = 0;
    args.short_dest.len = sizeof(i32);
    args.short_dest.addr = &status as *u8; 
    args.timeout = -1;
   
    assert!(ipc_recv(&args) >= 0);
    if (status < 0) {
        printf!("err %d\n", get_tid());
        abscond(-1);
    }

    while(true) {}

}

/* file_server_init: creates a file server with specified number of threads.
 * spins up a new process with a mailbox; all threads execute server_run.  if a
 * valid mailbox descriptor desc is specified, new server sends a message to the
 * mailbox with its descriptor.  Returns with error if threads or mailbox fail
 * to init
 *
 * - num_threads: number of threads for new server.  All threads exit and server
 *   sends failure to desc if all threads cannot be created
 * - desc: a descriptor for the mailbox to which the server sends its status.
 *   On error, it sends an error code.  Otherwise, it sends the descriptor for the
 *   file server
 *
 * Returns error if repl fails, 0 otherwise.  
 *
 * NOTE catching further errors requires sending a descriptor and waiting on
 * that mailbox for a status.
 * NOTE if a valid descriptor desc is given but no thread ever waits on desc,
 * server can fail to properly init (if async send fails)
*/

fn file_server_init(num_threads: u32, desc: i32) -> i32 {
    let status: i32 = 0;
    /* for sending a status to a descriptor */
    let args: ipc_args;
    args.dest_id = desc as u32;
    args.long_src.len = 0;
    args.short_src.len = sizeof(i32);
    args.short_src.addr = &status as *u8;
    args.timeout = -1;
    args.options = OPTION_ASYNC;

    /* creating file server proc */
    let ret = repl();
    if (ret < 0) {
        return -1;
    }
    if (ret == 0) {
        /* file server creates own mailbox */
        let mb: i32 = -1;
        if ((mb = mailbox_new()) < 0) {
            if (desc > 0) {
                // on error send, error code to descriptor 
                status = -1;
                ipc_send(&args);
            }
            abscond(-1);
        }
        let i: u32;
        // spin up the specified number of threads; quit early if thread
        // creation fails
        for (i = 0; i < num_threads; i+=1) {
            printf!("creating thread %d\n", i);
            if ((ret = thr_create(run_server, mb as *u8)) < 0) {
                // TODO task_vanish or cond var
                status = -2;
                num_threads = i;
                break; 
            } 
        }

        assert!(mb >= 0);
        args.dest_id = mb as u32;
        args.options = OPTION_NO_REPLY;

        // wake up child threads either with success (run server) or error
        // (abscond immediately)
        // do this before the outside proc in case they attempt to wait on our
        // mailbox and ruin everything 
        for (i = 0; i < num_threads; i+=1) {
            printf!("waking up thread %d\n", i);
            assert!(ipc_send(&args) >= 0);
        }

        // wake up thread waiting on given mailbox
        if (desc > 0) {
            args.dest_id = desc as u32;
            args.options = OPTION_ASYNC;
            if (status >= 0) {
                status = mb;
            }
            // if async fails due to memory, send a synchronous message instead
            if (ipc_send(&args) == IPC_ERR_INTERNAL) {
                args.options = OPTION_NO_REPLY;
                ipc_send(&args); 
            }
        }
        printf!("exiting\n");
        abscond(status);

        assert!(false); // no return
    }

    0
}



/*** client code ***/
/* send a new file name and some data to start the new file.  returns with error
 * if ipc fails, or if the file already exists */
fn create(name: *u8, buffer: *u8, buffer_len: u32) -> i32 {
    if (strnlen(name, NAME_MAX + 1) > NAME_MAX) {
        return -1;
    }
    // TODO sanitize name input
    let message: file_message;
    let status_buffer: u32[5];
    let len = strncpy(&(message.name)[0], name, NAME_MAX);
    assert!(len <= NAME_MAX); 
    let args: ipc_defs::ipc_args;
    args.dest_id = SERVER_ID; 
    args.long_src.addr = buffer;
    // round up
    args.long_src.len = len + (len%4096);
    args.short_src.addr = &message as *u8;
    args.short_src.len = sizeof(file_message);
    args.long_dest.len = 0;
    args.short_dest.addr = &status_buffer[0] as *u8;
    args.short_dest.len = sizeof(u32) * 5;

    0
}
