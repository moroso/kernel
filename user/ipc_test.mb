/* ipc_test.mb 
 * Test of long IPC; repls a child thread, and then sends the page 0xdeadb000 to it
 * Author: Amanda M. Watson
*/

mod syslib;

fn main() -> i32 {
    while(true) {
        let ret = syslib::repl();
        if (ret != 0) {
            let page = 0xDEADB000 as *u8;
            printf!("calling new_pages on address %p\n", page);
            syslib::new_pages(page, 4096, 1024);
            *(page as *u32) = ret;
            let message: *u32 = syslib::get_tid() +1 as *u32;
            printf!("thread %d sent page %p with message %p\n", syslib::get_tid(),
                    page, message);
            let send_ret = syslib::ipc_send(ret, page, &message, 4096, 0);
            printf!("thread %d received message %p from send\n", syslib::get_tid(),
                    message);
            if ((message as u32) != ret) {
                printf!("***FAILURE***\n");
                syslib::abscond(-1);
            }


        } else {
            printf!("thread %d repled thread %d\n", ret, syslib::get_tid());
            let page = 0xDEADB000  + 4096 as *u8;

            let message: *u32 = syslib::get_tid() as *u32;

            let recv_ret = syslib::ipc_recv(page, &message, 4096, 0);
                        
            if (recv_ret < 0) {
                printf!("recv failed with error code %d\n", recv_ret);
                printf!("***FAILURE***\n");
                syslib::abscond(-1);  
            }

            printf!("thread %d received message %p\n", syslib::get_tid(),
                    message);
            if (message as u32 != 1) {
                printf!("failed message transfer!\n");
                printf!("***FAILURE***\n");
                syslib::abscond(-1);                
            }
            if (*(page as *u32) != syslib::get_tid()) {
                printf!("error: page does not hold previous value (%d)\n",
                        *(page as *u32));
                syslib::abscond(-2);
            }

            syslib::abscond(1);
        }

    }
    0
}
