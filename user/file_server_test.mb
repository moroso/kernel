/* file_server_test: tests file_server creation, name server registration, file create, write and read 
 * each thread manipulates its own file many times 
 * On success, ***SUCCESS*** will print NUM_PROCS times
*/

use server::*;
use syslib::*;
use thrlib::*;
use name::*;
use mallot::*;
use file::*;
use shared::consts::*;
use string::*;
use utils::asm::*;

const NUM_PROCS: u32 = 10;
const NUM_THREADS: u32 = 50;
const MAX_NAME_LEN: u32 = 100;

static num_threads: u32 = NUM_THREADS;

fn file_system_test(arg: *u8) {
    // all threads in the proc get a descriptor, duplicating the descriptor in
    // the lookup table 
    let fs_mb = -1;
    let ret = 0;
    if ((ret = name_server_request(FILE_SERVER_ID, &fs_mb, -1)) < 0) {
        printf!("error %d getting descriptor\n", ret);
    }

    let file_name_temp: u8[MAX_NAME_LEN];
    let file_name: *u8 = &file_name_temp[0];
    snprintf!(file_name, 99, "%d", get_tid());
     
    if ((ret = file_create(fs_mb, file_name, null, 0, -1)) < 0) {
        printf!("err creating file %s: %d\n", file_name, ret);
        abscond(-1);
    }
    let file_buffer = find_pages(1);
    if (file_buffer == null) {
        printf!("ERROR: cannot init write buffer\n");
        abscond(-1);
    }
   

    strncpy(file_buffer, file_name, MAX_NAME_LEN); 
    let i: u32 = 0;
    let offset = 0;
    for (i = 0; i < (PAGE_SIZE/MAX_NAME_LEN); i+=1) {
        if (file_write(fs_mb, file_name, file_buffer, MAX_NAME_LEN,
                    offset, -1) < 0) {
            printf!("write error\n");
            abscond(-1);
        }
        offset+=strnlen(file_name, PAGE_SIZE);
    }

    remove_pages(file_buffer, PAGE_SIZE);
    let read_buffer = find_pages(1);
    if (read_buffer == null) {
        printf!("ERROR: cannot init read buffer\n");
        abscond(-1);
    }
    
    let read_size = PAGE_SIZE;
    if (file_read(fs_mb, file_name, read_buffer, &read_size, 0, -1) < 0) {
        printf!("read error\n");
        abscond(-1);
    }

    let name_buffer_temp: u8[MAX_NAME_LEN];
    let name_buffer: *u8 = &name_buffer_temp[0];
    let file_name_len = strnlen(file_name, 100);
    
    offset = 0;
    for (i = 0; i < (PAGE_SIZE/MAX_NAME_LEN); i+=1) {
        strncpy(name_buffer, read_buffer + offset, file_name_len); 
        if (strcmp(name_buffer, file_name) != 0) {
            printf!("ERR READING FILE\n");
            abscond(-1);
        }
        offset+=file_name_len;
    }

    atomic_add(&num_threads, -1);
    abscond(0);
}

fn spawn_threads(num_threads: u32) {
    let i: u32;
    for (i = 0; i < num_threads; i+=1) {
        if (thr_create(file_system_test, null) < 0) {
            break;
        }
    }

}

fn spawn_procs(num_procs: u32) {
    let i: u32;
    for (i = 0; i < num_procs; i+=1) {
        if (repl() == 0) {
            mallot_init();
            break;
        }

    }

}

fn main() -> i32 {
    let mb = mailbox_new();
    if (mb < 0) {
        printf!("failed to allocate mailbox\n");
        abscond(-1);
    }
    /* init new file server -- when finished, it will return with its descriptor */
    let fs_mb = new_server(FILE_SERVER_ID, 100, mb);
    if (fs_mb < 0) {
        printf!("failed to init file server \n");
        abscond(-1);
    }

    spawn_procs(NUM_PROCS);
    spawn_threads(NUM_THREADS);

    while(num_threads > 0) {
        yield(-1);
    }
    printf!("***SUCCESS***\n");
    abscond(0);

    0
}


