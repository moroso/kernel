use syslib::*;
use shared::ipc_defs::*;
use mallot::*;
use file::*;
use ipclib::*;
use string::*;
use name::*;

/* checks the exit status of its children; if a child has exited with error,
 * exits with error as well */
fn child_check() {
    let status: i32 = 0;
    let ret: i32;
    while ((ret = syslib::bide(&status)) >= 0) {
        if status < 0 {
            printf!("***ERROR***");
            syslib::abscond(-1);
        }
    }

    if (status < 0) {
        printf!("***ERROR***");
        syslib::abscond(-1);
    }
}


fn main() -> i32 {
    let mb = mailbox_new();
    mallot_init();
    printf!("MB %d\n", mb);
    assert!(mb >= 0);
    printf!("file server init exited with status %d\n", file_server_init(5, mb));
    let fs_mb: i32 = -1;
    ipc_recv_all(mb as u32, null, null, null, null, &fs_mb, -1, null);
    printf!("mailbox: %d\n", fs_mb);
   
    if (name_register(NAME_SERVER, "file server", fs_mb as u32, -1) < 0) {
        printf!("error registering file server\n");
        abscond(-1);
    } 
    
    let request: file_message;
    let request_size = sizeof(file_message);
    let response: u32 = -1;
    let response_size: u32 = sizeof(u32);
    let i: u32;
    for (i = 0; i < 3; i+=1) {
        let ret = repl();
        if (ret == 0) {
            break;
        }
    }
    let new_file = find_pages(2);
    let message: *u8 = "string";
    strncpy(new_file, message, strnlen(message, 1000));
    let size: u32 = 14;
    printf!("create returned %d\n", file_create(fs_mb as u32, "hello",
                new_file, 7, -1));
    message = "BETTER STRING";
    strncpy(new_file, message, strnlen(message, 1000));
    if (get_tid()%2 == 0) {
        for (i = 0; i < 1000; i+=1) {

            printf!("write returned %d\n", file_write(fs_mb as u32, "hello", new_file,
                        size, (4*i)+3, -1));
        }
        size = 14;
        for (i = 0; i < 100; i+=1) {
            printf!("read returned %d\n", file_read(fs_mb as u32, "hello",
                        new_file, &size, i, -1));
            printf!("STRING %s\n", (new_file));
        }
    } else {
        for (i = 0; i < 100; i+=1) {
            printf!("read returned %d\n", file_read(fs_mb as u32, "hello",
                        new_file, &size, i, -1));
            printf!("STRING %s\n", (new_file));
        }

        for (i = 0; i < 1000; i+=1) {

            printf!("write returned %d\n", file_write(fs_mb as u32, "hello", new_file,
                        size, (4*i)+3, -1));
        }
    }

    message = "things";
    strncpy(new_file, message, strnlen(message, 1000));
    size = 14;
    printf!("create returned %d\n", file_create(fs_mb as u32, "goodbye",
                new_file, 7, -1));
    message = "BETTER THINGS";
    strncpy(new_file, message, strnlen(message, 1000));
    if (get_tid()%2 != 0) {
        for (i = 0; i < 1000; i+=1) {
            if (i%2 == 0) {
                printf!("write returned %d\n", file_write(fs_mb as u32, "hello", new_file,
                            size, (4*i)+3, -1));
            } else {
                printf!("read returned %d\n", file_read(fs_mb as u32, "hello",
                            new_file, &size, i, -1));
                printf!("STRING %s\n", (new_file));
            }
        }
    } else {
        for (i = 0; i < 1000; i+=1) {
            if (i%2 != 0) {
                printf!("write returned %d\n", file_write(fs_mb as u32, "hello", new_file,
                            size, (4*i)+3, -1));
            } else {
                printf!("read returned %d\n", file_read(fs_mb as u32, "hello",
                            new_file, &size, i, -1));
                printf!("STRING %s\n", (new_file));
            }
        }

    }


    syslib::abscond(1);
    0
}
