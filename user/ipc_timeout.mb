/* ipc_timeout.mb 
 * tests timeouts in send, recv and between recv and reply. Success condition
 * does not actuall check all threads, but errors are thrown if things go wrong 
 * Author: Amanda M. Watson
*/

mod syslib;
const NUM_ITERS: u32 = 20;
const NUM_THREADS: u32 = 50;

/* checks the exit status of its children; if a child has exited with error,
 * exits with error as well */
fn child_check() {
    let status: i32 = 0;
    while (syslib::bide(&status) > 0) {
        if status < 0 {
            printf!("***ERRROR***\n");
            syslib::abscond(-1);
        }
    }
    if (status < 0) {
        printf!("***ERRROR***\n");
        syslib::abscond(-1);
    }
}

fn main() -> i32 {
   
    let ret_1 = syslib::repl();
    if (ret_1 != 0) {
        child_check();
        printf!("***SUCCESS***\n");
        syslib::abscond(1);
    }

    let j: u32 = 0;

    let parent_1 = syslib::get_tid();
    for (j = 0; j < NUM_THREADS; j+=1) {

        if syslib::get_tid() != parent_1 {
            break;
        }
        syslib::repl();
    }
    let parent = syslib::get_tid();
    let ret: i32 = syslib::repl();

    /* create arg parameters */
    let args: syslib::shared::ipc_defs::ipc_args; 
    args.options = 0; // requires reply
    args.long_dest.len = 0;
    args.short_src.len = 0;
    args.long_src.len = 0;


    if (ret == 0) {
        args.dest_id = parent;
        args.timeout = -1;
        let message = -1; 
        args.short_dest.len = sizeof(u32); 
        args.short_dest.addr = &message;
        let send_ret: i32;
        if ((send_ret = syslib::ipc_send(&args)) != 0) {
            printf!("ERROR: thread %d returned from send with value %d. Expected 0", syslib::get_tid(), send_ret);
            syslib::abscond(-1);
        }
        if (message != 0) {
            printf!("ERROR: thread %d did not receive message\n",
                    syslib::get_tid());
            syslib::abscond(-1);

        }
        printf!("child received message!\n");
        syslib::abscond(1);
    } else {
        let i: u32 = 0;
        // tests timeout on send
        for (i = 0; i < NUM_ITERS; i+=1) {
            printf!("timeout: %d\n", i);
            args.dest_id = ret as u32;
            args.timeout = i; // no timeout
            let ticks_orig = syslib::get_ticks();
            let send_ret = syslib::ipc_send(&args);
            if (send_ret != -5) {
                printf!("ERROR thread %d returned from send with return value %d. expected -5\n", syslib::get_tid(), send_ret);
            }
            if (syslib::get_ticks() < ticks_orig + i) {
                printf!("error: thread %d returned prematurely\n",
                        syslib::get_tid());
                syslib::abscond(-1);
            }

            printf!("success!\n");
        }
        // tests timeout on receive
        let message: u32 = 0;
        args.dest_id = 0;
        syslib::ipc_recv(&args);
        syslib::ipc_reply(null, 0, &message, sizeof(u32));
        for (i = 0; i < NUM_ITERS; i+=1) {
            printf!("timeout: %d\n", i);
            args.dest_id = 0;
            args.timeout = i; // no timeout
            let ticks_orig = syslib::get_ticks();
            let recv_ret = syslib::ipc_recv(&args);
            if (recv_ret != -5) {
                printf!("ERROR thread %d returned from recv with return value %d. expected -5\n", syslib::get_tid(), recv_ret);
                syslib::abscond(-1);
            }

            if (syslib::get_ticks() < ticks_orig + i) {
                printf!("error: thread %d returned prematurely\n",
                        syslib::get_tid());
                syslib::abscond(-1);
            }
            printf!("success!\n");
        }
        for (i = 0; i < NUM_ITERS; i+=1) {
            let repl_ret = syslib::repl();
            if (repl_ret == 0) {
                args.dest_id = 0;
                args.long_dest.len = 0;
                args.short_dest.len = 0; 
                args.timeout = 100;
                assert!(syslib::ipc_recv(&args) == 0);
                let ticks = syslib::get_ticks();
                printf!("%d received; waiting before reply\n", syslib::get_tid());
                while(syslib::get_ticks() < (ticks + 50)) {

                }
                printf!("%d replying\n", syslib::get_tid());

                let reply_ret = syslib::ipc_reply(null, 0, null, 0);
                if (reply_ret != -4) {
                    printf!("%d ERROR in reply.  expected -4, got %d\n",
                            syslib::get_tid(), reply_ret);
                } else {
                    printf!("%d success!\n", syslib::get_tid());
                }
            } else {
                args.dest_id = repl_ret as u32;
                args.timeout = 50;
                args.short_src.len = 0; 
                args.long_src.len = 0;
                let ticks = syslib::get_ticks();
                printf!("%d waiting before send\n", syslib::get_tid());

                while(syslib::get_ticks() < (ticks + 8)) {

                }
                printf!("%d done waiting, sending to parent\n", syslib::get_tid());

                let send_ret = syslib::ipc_send(&args);
                if (send_ret != -5) {
                    printf!("%d ERROR from send.  Expected -5, received %d\n",
                            syslib::get_tid(),
                            send_ret);
                } else {
                    printf!("%d success!\n", syslib::get_tid());
                }

                syslib::abscond(1);
            } 


        }

    }
    syslib::abscond(1);
    0
}
