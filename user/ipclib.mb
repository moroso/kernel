/* Some wrappers for ipc 
 *
 */

use prelude::syslib::*;
use prelude::shared::ipc_defs::*;

/* TODO again with the not being able to make things const -- what is up with that? */
static IPC_NO_ID: u32 = -1 as u32;
static IPC_NO_LEN: u32 = 0;
static IPC_NO_ADDR: *u8 = null;
static IPC_NO_DESC: i32 = -1; 
static IPC_NO_TIMEOUT: u32 = -1 as u32;
static IPC_OPTION_DEFAULT: u32 = 0;

// sets all args to default values 
// message fields sent with default values will not have information read from
// or written to them
fn ipc_args_init(args: *ipc_args) {
    args->dest_id = IPC_NO_ID;
    args->long_src.len = IPC_NO_LEN;
    args->long_src.addr = IPC_NO_ADDR;
    args->long_dest.len = IPC_NO_LEN;
    args->long_dest.addr = IPC_NO_ADDR;
    args->short_src.len = IPC_NO_LEN;
    args->short_src.addr = IPC_NO_ADDR;
    args->short_dest.len = IPC_NO_LEN;
    args->short_dest.addr = IPC_NO_ADDR;
    args->desc_src = IPC_NO_DESC;
    args->desc_dest = IPC_NO_DESC;
    args->timeout = IPC_NO_TIMEOUT;
    args->options = IPC_OPTION_DEFAULT;
}

fn ipc_send_short(mb: u32, src_addr: *u8, src_len: u32, dest_addr: *u8, dest_len: *u32,
        async: bool, timeout: i32) -> i32 {


    let args: ipc_args;
    ipc_args_init(&args);
    args.dest_id = mb;
    args.short_src.addr = src_addr;
    args.short_src.len = src_len;
    args.timeout = timeout as u32;
    if (async) {
        args.options = OPTION_ASYNC;
    } else if (*dest_len == 0) {
        /* if no dest is specified, there's no reason to expect a reply */
        args.options = OPTION_NO_REPLY;
    } else {
        args.short_dest.addr = dest_addr;
        args.short_dest.len = *dest_len;
    }
    let ret = ipc_send(&args);
    if (ret >= 0) {
        // updated in args by ipc
        *dest_len = args.short_dest.len;
    }

    ret
}

fn ipc_forward_desc(mb: u32, desc: u32, dest_addr: *u8, dest_len: u32, async: bool,
        timeout: i32) -> i32 {
    let args: ipc_args;
    ipc_args_init(&args);

    0
}

fn ipc_recv_all(mb: u32, long_addr: *u8, long_len: *u32, short_addr: *u8, short_len: *u32,
        desc: *i32, timeout: i32, reply_needed: *bool) -> i32 {

    let args: ipc_args;
    ipc_args_init(&args);
    args.dest_id = mb;
    args.long_dest.addr = long_addr;
    if (long_len != null) {
        args.long_dest.len = *long_len;
    }
    args.short_dest.addr = short_addr;
    if (short_len != null) {
        args.short_dest.len = *short_len;
    }
    args.timeout = timeout as u32;	
    let ret = ipc_recv(&args);
    if (ret >= 0) {
        if (short_len != null) {
            *short_len = args.short_dest.len;
        }
        if (long_len != null) {
            *long_len = args.long_dest.len;
        }
        if (desc != null) {
            *desc = args.desc_dest;
        }
        if (reply_needed != null) {
            // TODO options for reply_needed
        }
    }

    ret
}


