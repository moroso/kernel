use prelude::server::*;
use prelude::rt_abort;
use prelude::syslib::{get_tid, new_vid_buffer, free_vid_buffer, remove_pages};
use prelude::ipclib::{ipc_recv_long, ipc_send_long, ipc_reply_i32, ipc_reply};
use prelude::locks::mutex::*;
use prelude::shared::consts::{PAGE_SIZE, USER_MEM_START, VID_REGION_SIZE};
use prelude::mallot::find_pages;
use prelude::utils::stdlib::mos_memcpy;

const CONSOLE_SERVER_ID: *u8 = "console_server";
static console_server_active: bool = false;

struct console_request {
    tid: u32,
    buffer_id: u32,
    buffer_size: u32,
}

static buffer_lock: mut_t = MUTEX_INIT!();
static VID_BUFFER: *u8 = 0xdeadb000 as *u8;
static BUFFER_SIZE: u32 = PAGE_SIZE * VID_REGION_SIZE;

/* initializes server thread and processes requests */
fn console_worker(mb_arg: *u8) {

    /*** setup ***/
    let mb = mb_arg as i32;
    assert!(mb >= 0);

    // we do this here so that no threads proceed before each worker has its own
    // buffer -- otherwise, we could accidentally do re-allocations in the loop
    let request_buffer = find_pages(VID_REGION_SIZE);

    if (server_thread_init(mb as u32) < 0) {
        server_thread_exit(&console_server_active, -1); 
    } 

    if (request_buffer == null) {
        server_thread_exit(&console_server_active, -2); 

    }

    let request: console_request;

    while(console_server_active) {

        let status: i32 = 0;
        let request_size: u32 = sizeof(console_request);
        let page_req_size: u32 = BUFFER_SIZE;
        if (ipc_recv_long(mb as u32, request_buffer, &page_req_size, &request as *u8, &request_size, -1, null)
                >= 0  && request_size == sizeof(console_request) &&
                page_req_size == BUFFER_SIZE) {
            // do any computation we need to decide whether the request should be given
            // access to the screen

            mut_lock(&buffer_lock);
            mos_memcpy(VID_BUFFER, request_buffer, BUFFER_SIZE);
            mut_unlock(&buffer_lock);

            ipc_reply(request_buffer, BUFFER_SIZE, &status as
                    *u32, sizeof(i32));

            remove_pages(request_buffer, BUFFER_SIZE);
        } 

    } 

    server_thread_exit(&console_server_active, 0); 
} 

/* called from console program to initialize server
 *
 * num_threads: number of worker threads in server
 * mb: mailbox to send a wakeup message to. ignored if mb is negative 
 * returns on failure 
 */
fn console_init(num_threads: u32, mb: i32) -> i32 {
    // get the VESA buffer for ourselves
    if (new_vid_buffer(VID_BUFFER) < 0) {
        return -2;
    }
    server_init(CONSOLE_SERVER_ID, &console_server_active, num_threads,
            console_worker, mb, true, -1);        
    -1
}

/* sends buffer use request to console.  Client blocks until request is serviced by server.  
 * fails if console server is unable or unwilling to display buffer  
 *
 * console_mb: mailbox descriptor for the console.  Must be a valid descriptor.
 * buffer_id: id for buffer retrieved from get_buffer syscall
 * buffer_size: size of content in buffer
 * timeout: how long client should wait for request before timing out. 
 */
fn use_console(console_mb: u32, buffer: *u8, timeout: i32) -> i32 {
    let request: console_request;
    request.tid = get_tid();
    let status: i32 = 0;
    let status_size: u32 = sizeof(i32);
    let buffer_len: u32 = BUFFER_SIZE;
    let ret = ipc_send_long(console_mb, buffer, buffer_len, &request as *u8,
            sizeof(console_request), buffer, &buffer_len, &status
            as *u8, &status_size, timeout, false);

    if (ret < 0) {
        return ret;
    }

    status
}
