use prelude::server::*;
use prelude::rt_abort;
use prelude::syslib::{get_tid, new_vid_buffer, free_vid_buffer};
use prelude::ipclib::{ipc_recv_short, ipc_send_long, ipc_reply_i32, ipc_reply};
use prelude::locks::mutex::*;
use prelude::shared::consts::{PAGE_SIZE, USER_MEM_START};

const CONSOLE_SERVER_ID: *u8 = "console_server";
static console_server_active: bool = false;

struct console_request {
    tid: u32,
    buffer_id: u32,
    buffer_size: u32,
}

static heap_end: *u8 = 0xffffe000 as *u8; 
static heap_pointer: *u8 = 0x4001e000 as *u8;  
static page_lock: mut_t = MUTEX_INIT!();

// finds an address that can get backed by video mem
fn find_vid_buffer() -> *u8 {

    let heap_cur = heap_pointer;
    let ret: i32;
    mut_lock(&page_lock);

    while((heap_pointer-=PAGE_SIZE) != heap_cur) {
        if (heap_pointer < USER_MEM_START as *u8) {
            heap_pointer = heap_end; 
        }    
        if ((ret = new_vid_buffer(heap_pointer)) >= 0) {
            let new_addr = heap_pointer;
            mut_unlock(&page_lock);
            return new_addr;
        }
        // if we don't get a collision or wrapping error, return immediately  
        // TODO error codes
        if (ret != -6 && ret != -1) {
            heap_pointer+=PAGE_SIZE;
            mut_unlock(&page_lock);
            return null;
        }
    }

    mut_unlock(&page_lock);
    null
}

/* initializes server thread and processes requests */
fn console_worker(mb_arg: *u8) {

    /*** setup ***/
    let mb = mb_arg as i32;
    assert!(mb >= 0);

    if (server_thread_init(mb as u32) < 0) {
        server_thread_exit(&console_server_active, -1); 
    } 

    let request: console_request;

    while(console_server_active) {
        let status: i32 = 0;
        let request_size: u32 = sizeof(console_request);
        if (ipc_recv_short(mb as u32, &request as *u8, &request_size, -1, null)
                >= 0  && request_size == sizeof(console_request)) {
            printf!("%d received a message from thread %d\n",
                    get_tid(), request.tid);    

            /// process buffer request
            let buffer = find_vid_buffer();
            if (buffer == null) {
                status = -1;
                ipc_reply_i32(&status); 
            } else {
                if (ipc_reply(buffer, PAGE_SIZE, &status as *u32, sizeof(i32)) <
                        0) {
                    free_vid_buffer(buffer);
                }
            }
        }

    }

    server_thread_exit(&console_server_active, 0); 
} 

/* called from console program to initialize server
 *
 * num_threads: number of worker threads in server
 * mb: mailbox to send a wakeup message to. ignored if mb is negative 
 * returns on failure 
 */
fn console_init(num_threads: u32, mb: i32) -> i32 {
    server_init(CONSOLE_SERVER_ID, &console_server_active, num_threads,
            console_worker, mb, true, -1);        
    -1
}

/* sends buffer use request to console.  Client blocks until request is serviced by server.  
 * fails if console server is unable or unwilling to display buffer  
 *
 * console_mb: mailbox descriptor for the console.  Must be a valid descriptor.
 * buffer_id: id for buffer retrieved from get_buffer syscall
 * buffer_size: size of content in buffer
 * timeout: how long client should wait for request before timing out. 
 */
fn use_console(console_mb: u32, buffer: *u8, timeout: i32) -> i32 {
    let request: console_request;
    request.tid = get_tid();
    let status: i32 = 0;
    let status_size: u32 = sizeof(i32);
    let buffer_len: u32 = PAGE_SIZE;
    let ret = ipc_send_long(console_mb, null, 0, &request as *u8,
            sizeof(console_request), buffer, &buffer_len, &status
            as *u8, &status_size, timeout, false);

    if (ret < 0) {
        return ret;
    }

    status
}
