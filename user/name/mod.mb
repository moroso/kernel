/* name/mod.mb: name server.  services requests for descriptors. 
 *
 * Author Amanda M. Watson
**/

use prelude::utils::list::*;
use prelude::locks::mutex::*;
use prelude::mallot::*;
use prelude::string::*;
use prelude::syslib::*;
use prelude::utils::asm::*;
use prelude::ipclib::*;
use prelude::thrlib::*;
use prelude::rt_abort;
use prelude::shared::ipc_defs::*;
use prelude::utils::asm::*;
use prelude::server::*;

const NAME_MAX: u32 = 64;
// id of name server
const NAME_SERVER: u32 = 0;

struct server_node {
    name: u8[NAME_MAX],
    desc: u32, 
    ref_count: u32,
    link: list_node,
}

struct name_request {
    name: u8[NAME_MAX],
    request_type: u32,
}

/*** request types ***/
const NAME_REGISTER: u32 = 0;
const NAME_REQUEST: u32 = 1;

// list of server descs 
static server_list: list_head = LIST_HEAD_INIT!(server_list);
static server_lock: mut_t = MUTEX_INIT!();

static name_server_active: bool = false;

fn new_server_node(name: *u8, desc: u32) -> *server_node {
    let new_node = mallot(sizeof(server_node)) as *server_node;
    if (new_node == null) {
        return null;
    }

    strncpy(&(new_node->name)[0], name, NAME_MAX);
    new_node->desc = desc;
    list_init_node(&new_node->link);
    new_node->ref_count = 1;

    new_node
}

fn inc_server_ref(node: *server_node) {
    atomic_add(&node->ref_count, 1);
}

fn dec_server_ref(node: *server_node) {
    let old_ref = atomic_add(&node->ref_count, -1);
    if (old_ref == 1) {
        lib(node as *u32, sizeof(server_node));
    }
}

fn server_lookup(name: *u8) -> *server_node {
    let node: *server_node = null;
    mut_lock(&server_lock);
    list_foreach_entry!(node, &server_list, server_node, link, {
            if (strcmp(name, &(node->name)[0]) == 0) {
            inc_server_ref(node);    
            mut_unlock(&server_lock);
            return node;
            }
            if (name[0] < node->name[0]) {
                break;
            }
            });

    mut_unlock(&server_lock);
    null
}

fn server_end_lookup(node: *server_node) {
    dec_server_ref(node);
}

fn request_desc(name: *u8) -> i32 {
    let node = server_lookup(name);
    if (node == null) {
        return -1;
    } 
    let desc = node->desc;
    server_end_lookup(node);
    desc as i32 
}

fn server_list_insert(new_node: *server_node) -> i32 {
    mut_lock(&server_lock);
    let node: *server_node = null;
    list_foreach_entry!(node, &server_list, server_node, link, {
            if (strcmp(&(new_node->name)[0], &(node->name)[0]) == 0) {
            mut_unlock(&server_lock);
            return -1;
            }
            if (node->name[0] > new_node->name[0]) {
            list_insert_before(&new_node->link, &node->link);
            mut_unlock(&server_lock);

            return 0;
            }
            });

    list_insert_tail(&new_node->link, &server_list);
    mut_unlock(&server_lock);

    0
} 

fn run_name_server(mb_arg: *u8) {
    /*** setup ***/
    let mb = mb_arg as i32;
    assert!(mb >= 0);

    if (server_thread_init(mb as u32) < 0) {
        server_thread_exit(&name_server_active, -1);
    }

    let status: i32 = -1; 
    let client_desc: i32 = -1;
    let request: name_request;
    let request_size = sizeof(name_request); 

    while(name_server_active) {
        request_size = sizeof(name_request);
        if (ipc_recv_mb(mb as u32, &client_desc, &request as *u8, &request_size, -1, null) >=
                0) {
            if (request_size != sizeof(name_request)) {
                status = -1;
                ipc_reply(null, 0, &status as *u32, sizeof(i32));

            } else {
                if (request.request_type == NAME_REGISTER) {
                    printf!("MESSAGE RECEIVED: %s\n", &request.name[0]);
                    let new_node = new_server_node(&request.name[0], client_desc as
                            u32);
                    if (new_node == null || server_list_insert(new_node) < 0) {
                        status = -1;
                        if (new_node != null) {
                            dec_server_ref(new_node);
                        }
                        ipc_reply(null, 0, &status as *u32, sizeof(i32));
                    }

                    ipc_reply(null, 0, null, 0);
                } else if (request.request_type == NAME_REQUEST) {
                    let return_desc = request_desc(&(request.name)[0]);
                    ipc_reply_mb(null, 0, return_desc as u32); 
                }
            }
        } 

    }
    printf!("thread %d exiting server\n", get_tid());
    server_thread_exit(&name_server_active, 0);
}

fn name_server_init(num_threads: u32, return_desc: i32) -> i32 {
    server_init(&name_server_active, num_threads, run_name_server, return_desc)
}

fn server_request(name_desc: u32, name: *u8, desc: *i32, timeout: i32) -> i32 {
    if (strnlen(name, NAME_MAX + 1) > NAME_MAX) {
        return -1;
    }

    let request: name_request;
    request.request_type = NAME_REQUEST;
    strncpy(&(request.name)[0], name, NAME_MAX);
    let status: i32 = -2;
    let status_size: u32 = sizeof(i32);
    let ret = ipc_request_mb(name_desc, &request as *u8, sizeof(name_request),
            &status as *u8, &status_size, desc, false, timeout);

    if (ret >= 0 && status_size == sizeof(u32)) {
        return status;
    }
    ret


}

fn server_register(name_desc: u32, name: *u8, desc: u32, timeout: i32) -> i32 {
    if (strnlen(name, NAME_MAX + 1) > NAME_MAX) {
        return -1;
    }

    let request: name_request;
    request.request_type = NAME_REGISTER;
    strncpy(&(request.name)[0], name, NAME_MAX);
    let status: i32 = -2;
    let status_size: u32 = sizeof(i32);
    let ret = ipc_forward_mb(name_desc, desc, &request as *u8, sizeof(name_request),
            &status as *u8, &status_size, false, timeout);

    if (ret >= 0 && status_size == sizeof(u32)) {
        return status;
    }

    ret
}
