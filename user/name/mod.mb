/* name/mod.mb: name server.  services requests for descriptors. 
 *
 * Author Amanda M. Watson
**/

use prelude::utils::list::*;
use prelude::locks::mutex::*;
use prelude::mallot::*;
use prelude::string::*;
use prelude::syslib::*;
use prelude::utils::asm::*;
use prelude::ipclib::*;
use prelude::thrlib::*;
use prelude::rt_abort;
use prelude::shared::ipc_defs::*;
use prelude::utils::asm::*;

const NAME_MAX: u32 = 64;
// id of name server
const NAME_SERVER: u32 = 0;

struct server_node {
    name: u8[NAME_MAX],
    desc: u32, 
    ref_count: u32,
    link: list_node,
}

struct name_request {
    name: u8[NAME_MAX],
    request_type: u32,
}

/*** request types ***/
const NAME_REGISTER: u32 = 0;
const NAME_REQUEST: u32 = 1;

// list of server descs 
static server_list: list_head = LIST_HEAD_INIT!(server_list);
static server_lock: mut_t = MUTEX_INIT!();

static name_server_active: bool = false;
static threads_dormant: u32 = 0;
static threads_active: u32 = 0;

fn new_server_node(name: *u8, desc: u32) -> *server_node {
    let new_node = mallot(sizeof(server_node)) as *server_node;
    if (new_node == null) {
        return null;
    }

   strncpy(&(new_node->name)[0], name, NAME_MAX);
   new_node->desc = desc;
   list_init_node(&new_node->link);
   new_node->ref_count = 1;

    new_node
}

fn inc_server_ref(node: *server_node) {
    atomic_add(&node->ref_count, 1);
}

fn dec_server_ref(node: *server_node) {
    let old_ref = atomic_add(&node->ref_count, -1);
    if (old_ref == 1) {
        lib(node as *u32, sizeof(server_node));
    }
}

fn server_lookup(name: *u8) -> *server_node {
    let node: *server_node = null;
    mut_lock(&server_lock);
    list_foreach_entry!(node, &server_list, server_node, link, {
            if (strcmp(name, &(node->name)[0]) == 0) {
            inc_server_ref(node);    
            mut_unlock(&server_lock);
            return node;
            }
            });

    mut_unlock(&server_lock);
    null
}

fn server_end_lookup(node: *server_node) {
    dec_server_ref(node);
}

fn request_desc(name: *u8) -> i32 {
    let node = server_lookup(name);
    if (node == null) {
        return -1;
    } 
    let desc = node->desc;
    server_end_lookup(node);
    desc as i32 
}

fn server_list_insert(new_node: *server_node) -> i32 {
    mut_lock(&server_lock);
    let node: *server_node = null;
    list_foreach_entry!(node, &server_list, server_node, link, {
            if (strcmp(&(new_node->name)[0], &(node->name)[0]) == 0) {
            mut_unlock(&server_lock);
            return -1;
            }
            if (node->name[0] > new_node->name[0]) {
            list_insert_before(&new_node->link, &node->link);
            mut_unlock(&server_lock);

            return 0;
            }
            });

    list_insert_tail(&new_node->link, &server_list);
    mut_unlock(&server_lock);

    0
} 

fn run_name_server(mb_arg: *u8) {
    /*** setup ***/
    let mb = mb_arg as i32;
    assert!(mb >= 0);
    let status: i32 = -1; 

    assert!(ipc_recv_i32(mb as u32, &status, -1, null) >= 0);
    if (status < 0) {
        printf!("err %d (%d)\n", get_tid(), status);
        name_server_active = false;
        abscond(-1);
    }

    printf!("thread %d waiting for wakeup\n", get_tid());
    atomic_add(&threads_dormant, -1);
    while (threads_dormant > 0) {
        yield(-1);
    }
    assert!(threads_dormant >= 0);

    printf!("thread %d running server\n", get_tid());
    atomic_add(&threads_active, 1); 

    let client_desc: i32 = -1;
    let request: name_request;
    let request_size = sizeof(name_request); 
    while(name_server_active) {
        request_size = sizeof(name_request);
        if (ipc_recv_mb(mb as u32, &client_desc, &request as *u8, &request_size, -1, null) >=
                0) {
            if (request_size != sizeof(name_request)) {
                status = -1;
                ipc_reply(null, 0, &status as *u32, sizeof(i32));

            } else {
                if (request.request_type == NAME_REGISTER) {
                    printf!("MESSAGE RECEIVED: %s\n", &request.name[0]);
                    let new_node = new_server_node(&request.name[0], client_desc as
                            u32);
                    if (new_node == null || server_list_insert(new_node) < 0) {
                        status = -1;
                        if (new_node != null) {
                            dec_server_ref(new_node);
                        }
                        ipc_reply(null, 0, &status as *u32, sizeof(i32));
                    }

                    ipc_reply(null, 0, null, 0);
                } else if (request.request_type == NAME_REQUEST) {
                    let return_desc = request_desc(&(request.name)[0]);
                    ipc_reply_mb(null, 0, return_desc as u32); 
                }
            }
        } 

    }
    printf!("thread %d exiting server\n", get_tid());
    abscond(0);

}

fn name_server_init(num_threads: u32, return_desc: u32) -> i32 {

    let status: i32 = 0; 

    let ret = repl();
    if (ret < 0) {
        return -1;
    }

    if (ret != 0) {
        return 0;
    }

    // mailbox for the server
    let mb: i32;
    if ((mb = mailbox_new()) < 0) {
        status = -1;
        ipc_send_short(return_desc, &status as *u8, sizeof(u32), null,
                null, false, -1);
    }

    // spin up the specified number of threads; quit early if thread
    // creation fails
    let i: u32 = 0;
    for (i = 0; i < num_threads; i+=1) {
        printf!("creating thread %d\n", i);
        if ((ret = thr_create(run_name_server, mb as *u8)) < 0) {
            // TODO task_vanish or cond var
            status = -2;
            num_threads = i;
            break; 
        } 
    }

    assert!(mb >= 0);

    if (status >= 0) {
        atomic_add(&threads_dormant, num_threads);
        // we set this before the server is truly active, but it's ok,
        // because nothing will get sent to the mailbox until we end out the
        // descriptor, which happens after the threads wake up
        name_server_active = true;
    }

    // wake up child threads either with success (run server) or error
    // (abscond immediately)
    // do this before waking the proc waiting on desc in case they attempt to wait on our
    // mailbox and ruin everything 
    for (i = 0; i < num_threads; i+=1) {
        printf!("waking up thread %d with status %d\n", i, status);
        let ret = ipc_send_i32(mb as u32, &status, null, null, false, -1);
        if (ret < 0) {
            printf!("%d\n", ret);
        }
        assert!(ret >= 0);
    }

    // wake up thread waiting on given mailbox
    if (return_desc >= 0) {

        // wait until server is fully active
        while(threads_dormant > 0) {
            yield(-1);
        }

        if (status < 0) {

            // if async fails due to memory, send a synchronous message instead
            if (ipc_send_i32(mb as u32, &status, null, null, true, -1) == IPC_ERR_INTERNAL) {
                ipc_send_i32(mb as u32, &status, null, null, false, -1);
            }
        } else {

            // if the sender isn't waiting, we're blocked forever.
            // This is probably better than timing out and leaving
            // the sender potentially blocked
            ipc_forward_mb(return_desc as u32, mb as u32, null, 0, null,
                    null, false, -1);
        }
    }
    mailbox_remove(return_desc as u32);
    printf!("exiting\n");
    abscond(status);

    assert!(false); // no return
    0
}

fn name_register(name_desc: u32, name: *u8, desc: u32, timeout: i32) -> i32 {

    if (strnlen(name, NAME_MAX + 1) > NAME_MAX) {
        return -1;
    }

    let request: name_request;
    request.request_type = NAME_REGISTER;
    strncpy(&(request.name)[0], name, NAME_MAX);
    let status: i32 = -2;
    let status_size: u32 = sizeof(i32);

    let ret = ipc_forward_mb(name_desc, desc, &request as *u8, sizeof(name_request),
            &status as *u8, &status_size, false, timeout);

    if (ret >= 0 && status_size == sizeof(u32)) {
        return status;
    }
    ret
}

fn server_request(name_desc: u32, name: *u8, desc: *i32, timeout: i32) -> i32 {
    if (strnlen(name, NAME_MAX + 1) > NAME_MAX) {
        return -1;
    }

    let request: name_request;
    request.request_type = NAME_REQUEST;
    strncpy(&(request.name)[0], name, NAME_MAX);
    let status: i32 = -2;
    let status_size: u32 = sizeof(i32);
    let ret = ipc_request_mb(name_desc, &request as *u8, sizeof(name_request),
            &status as *u8, &status_size, desc, false, timeout);

    if (ret >= 0 && status_size == sizeof(u32)) {
        return status;
    }
    ret


}
