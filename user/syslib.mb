use prelude::shared;
extern fn syscall_0(idx: u32) -> u32;
extern fn syscall_1(idx: u32, arg1: u32) -> u32;
extern fn syscall_2(idx: u32, arg1: u32, arg2: u32) -> u32;
extern fn syscall_3(idx: u32, arg1: u32, arg2: u32, arg3: u32) -> u32;
extern fn syscall_4(idx: u32, arg1: u32, arg2: u32, arg3: u32, arg4: u32) -> u32;
extern fn syscall_5(idx: u32, arg1: u32, arg2: u32, arg3: u32, arg4: u32, arg5:
u32) -> u32;

struct buffer_t {
    addr: *u8,
    len: u32,
}

// A system call
fn test_sys(arg: u32) -> u32 {
    syscall_1(1, arg)
}

fn repl() -> i32 {
    syscall_0(shared::syscall_consts::INT_REPL) as i32
}

fn abscond(status: i32) {
    syscall_1(shared::syscall_consts::INT_ABSCOND, status as u32);
}

fn bide(pointer: *i32) -> i32 {
    syscall_1(shared::syscall_consts::INT_BIDE, pointer as u32) as i32
}

fn print(s: *u8, n: u32) {
    syscall_2(shared::syscall_consts::INT_PRINT, s as u32, n);
}

fn get_tid() -> u32 {
    syscall_0(shared::syscall_consts::INT_GETTID)
}

fn perform(filename: *u8) -> i32 {
    syscall_1(shared::syscall_consts::INT_PERFORM, filename as u32) as i32
}

fn ipc_send(args: *shared::ipc_defs::ipc_args) -> i32 {
				syscall_1(shared::syscall_consts::INT_IPC_SEND, args as u32) as i32
}

fn new_pages(addr_start: *u8, len: u32, size: u32) -> i32 {
				syscall_3(shared::syscall_consts::INT_NEW_PAGES, addr_start as u32, len,
												size) as i32
}

fn ipc_recv(args: *shared::ipc_defs::ipc_args) -> i32 {
				syscall_1(shared::syscall_consts::INT_IPC_RECV, args as u32) as i32
}

fn get_ticks() -> u32 {
				syscall_0(shared::syscall_consts::INT_GET_TICKS) as u32
}

fn ipc_reply(message_long: *u8, long_len: u32, message_short: *u32, short_len:
u32) -> i32 {
    syscall_4(shared::syscall_consts::INT_IPC_REPLY, message_long as u32,
            long_len, message_short as u32, short_len) as i32
}

// returns descriptor if works, negative error code otherwise
fn mailbox_new() -> i32 {
    syscall_0(shared::syscall_consts::INT_MAILBOX_NEW) as i32
}

// creates a new descriptor for mb_src in the proc receiving on mb_dest.  if creation is
// successful, send a short async message to mb_dest with the new descriptor.
fn mailbox_forward(mb_src: u32, mb_dest: u32) -> i32 {

    let new_desc = syscall_2(shared::syscall_consts::INT_MAILBOX_FORWARD, mb_src
            as u32, mb_dest as u32) as i32;

    if (new_desc < 0) {
        return new_desc;
    }

    // send descriptor to dest mailbox
    let args: shared::ipc_defs::ipc_args;
    args.dest_id = mb_dest;
    args.long_src.len = 0;
    args.short_src.len = sizeof(i32);
    args.short_src.addr = &new_desc as *u8;
    args.options = shared::ipc_defs::OPTION_ASYNC;
    if (ipc_send(&args) == shared::ipc_defs::IPC_ERR_INTERNAL) {
        // TODO delete descriptor in dest proc
        return -7;
    }
    0
}

// no dumb syscall name this time.  Sorry to disappoint
fn yield(tid: u32) -> i32 {
    syscall_1(shared::syscall_consts::INT_YIELD, tid) as i32
}
