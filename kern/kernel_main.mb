/*** Helpful register functions ***/
extern fn get_cr0() -> u32;
extern fn get_cr2() -> u32;
extern fn get_cr3() -> u32;
extern fn get_cr4() -> u32;
extern fn set_cr0(val: u32);
extern fn set_cr3(val: u32);
extern fn set_cr4(val: u32);


fn parent() {
    let page: *u8 = USER_MEM_START as *u8;
    while (page as u32 < (USER_MEM_START + (4096*4))) {
        if (new_user_page(page, &(get_tcb()->proc->PD), READ_WRITE_BIT, KB) < 0) {
            printf2_("failed to allocate page %x for thread %d\n", page as u32,
                    get_tcb()->tid);
            break;
        }
        *(page as *u32) = get_tcb()->tid;
        page = ((page as u32)) + 4096 as *u8;
    }

    repl(get_tcb()->context);
    printf1_("Thread %d forked\n", get_tcb()->tid);
    let status: u32;
    bide(&status);
    printf2_("Thread %d collected status %d\n", get_tcb()->tid, status);
    abscond();

}

fn idle() {
    while (true) {
        printf0_("idle\n");
        scheduler_update(-1);
    }
}

fn kernel_setup() {
    /* this is what we do to avoid trying to wrangle the frame
     * allocator's powers-of-two bullshit */
    /* TODO get rid of this bullshit */
    let frame_table_size: u32 = sizeof(u32) * MAX_FRAME_NUM;
    let x: *u32 = early_alloc(frame_table_size);
    frame_table = x;
    assert(frame_table != null);

    /*** Basic util initialization ***/
    frame_init();
    slub_init();

    /*** Create an initial page directory and enable paging ***/
    init_PD = slub_alloc(sizeof(PD_t)) as *PD_t; // should be sizeof()
    assert(PD_init(init_PD) >= 0);
    entry_setup();
    load_PD(init_PD);
    enable_paging();

    fs_init();
}

fn kernel_main() -> u32 {
    kernel_setup();


    /*** Create two threads and schedule them ***/

    let i: u32;
    for (i = 0; i < 5; i+=1) {
        let new_tcb: *tcb = thr_create(&parent as *u8, null, 0);
        assert(new_tcb != null);
        let proc1: *proc = slub_alloc(sizeof(proc)) as *proc;
        proc_init(proc1, new_tcb);
        assert(proc1 != null);
        schedule(new_tcb, QUEUE_FRONT);
    }

    let new_tcb: *tcb = thr_create(&idle as *u8, null, 0);
    assert(new_tcb != null);
    let proc1: *proc = slub_alloc(sizeof(proc)) as *proc;
    proc_init(proc1, new_tcb);
    assert(proc1 != null);
    schedule(new_tcb, QUEUE_FRONT);


    /*** Switch to the first thread in the run queue and jump to its execution ***/
    scheduler_update(-1);
    while (true) {};
    0




}
