use consts;
use structures::tcb::gpregs;
use structures::VM::*;
use structures::schedule::*;
use locks::mutex::*;
use locks::rendezvous::rend_timeout_remove;
use threadstuffs::abscond::abscond;
use drivers::keyboard::keyboard_handler;
mod devices;

const MAX_FAULT_NUMS: u32 = 256;

const PAGE_FAULT: u32 = 14;
const TIMER_INTER: u32 = 32;
const KBD_INTER: u32 = 33;
const SYSCALL: u32 = 0x80;

struct uregs {
    ds: u32,
    es: u32,

    gpregs: gpregs,

    pf_addr: u32,
    cause: u32,

    error_code: u32,
    eip: u32,
    cs: u32,
    eflags: u32,
    esp: u32,
    ss: u32,
}

static fault_table: (fn(*uregs) -> ())[MAX_FAULT_NUMS];

static ticks: u32 = 0;

extern fn idt_base() -> *u32;
extern fn entry_stubs();
const STUB_SIZE: u32 = 16;

fn entry_setup() {
    let b = idt_base();
    let addr = &entry_stubs as u32;

    let i: u32;
    for (i = 0; i < 256; i += 1) {
        b[i*2] = 0x00100000 | (addr & 0xFFFF);
        let dpl = 3;
        b[i*2+1] = (addr & 0xFFFF0000)
                  | 0x8e00 | (dpl << 13);

        addr += STUB_SIZE;
    }
}

fn register(idx: u32, handler: fn(*uregs) -> ()) {
    assert!(idx < MAX_FAULT_NUMS);
    assert!(fault_table[idx] as u32 == 0);
    fault_table[idx] = handler;
}

fn entry_init() {
    entry_setup();

    register(PAGE_FAULT, page_fault_handler);
    register(TIMER_INTER, timer_handler);
    register(KBD_INTER, keyboard_handler);
}

extern fn pic_acknowledge_any_master();

struct exception_record {
    try: u32,
    catch: u32
}
extern static user_copy_handler: exception_record;

fn page_fault_handler(regs: *uregs) {
    // If this happened at the try address userspace copy, then return
    // to the catch address.
    if regs->cs == consts::KERNEL_CS && regs->eip == user_copy_handler.try {
        regs->eip = user_copy_handler.catch;
        return ();
    }

    let PD: *PD_t = &(get_tcb()->proc->PD);
    kmut_lock(&PD->mut);
    let log_addr: *u8 = get_cr2() as *u8;
    let frame_addr: **u8 = log_to_phys(log_addr, PD);

    // if page is COW page, copy info onto new frame and replace
    if (frame_addr != null && has_flags(*frame_addr, COW_BIT)) {
        cow_copy(log_addr, PD);
    } else {
        let tid: u32 = -1;
        if (get_tcb() != null) {
            tid = get_tcb()->tid;
        }
        if (is_kernel_addr(log_addr)) {
            printf!("Thread %d, proc %d Page Fault on address 0x%x, instruction 0x%x, stack 0x%x (%p)\n", tid, get_tcb()->proc->pid,
                    log_addr, regs->eip, regs->esp,*log_to_phys(regs->esp as *u8, PD) );
            assert!(false);
        }


        if (frame_addr == null || *frame_addr == null) {
            printf!("Thread %d, proc %d Page Fault on address 0x%x, instruction 0x%x, stack 0x%x (%p) -- PAGE UNMAPPED\n", tid, get_tcb()->proc->pid,
                    log_addr, regs->eip, regs->esp,*log_to_phys(regs->esp as *u8, PD));

        } else if (!has_flags(*frame_addr, USER_SUPER_BIT)) {
            printf!("Thread %d, proc %d Page Fault on address 0x%x, instruction 0x%x, stack 0x%x (%p) -- INVALID ADDRESS \n", tid, get_tcb()->proc->pid,
                    log_addr, regs->eip, regs->esp,*log_to_phys(regs->esp as *u8, PD));

        } else if (!has_flags(*frame_addr, READ_WRITE_BIT)) {
            printf!("Thread %d, proc %d Page Fault on address 0x%x, instruction 0x%x, stack 0x%x (%p) -- READ ONLY PAGE \n", tid, get_tcb()->proc->pid,
                    log_addr, regs->eip, regs->esp,*log_to_phys(regs->esp as *u8, PD));

        } else { 
            kmut_unlock(&PD->mut);
            return ();
        }

        kmut_unlock(&PD->mut);
        abscond(-1);
    }
    kmut_unlock(&PD->mut);

}



fn timer_handler(regs: *uregs) {
    ticks += 1;
    pic_acknowledge_any_master();

    if (is_preempt_enabled()) {
        rend_timeout_remove(ticks);
        scheduler_update(-1);
    }
}

fn get_ticks() -> u32 {
    ticks
}

fn kbd_handler(regs: *uregs) {
    pic_acknowledge_any_master();

    printf!("took kbd interrupt, don't care\n");
}


fn kernel_entry(regs: *uregs) {
    let f: fn(*uregs) -> () = fault_table[regs->cause];
    if f as u32 == 0 {
        printf!("took a fault %u at 0x%08x\n", regs->cause, regs->eip);
        assert!(false);
    }

    f(regs);

}

extern fn leave_kernel(ureg: *uregs);
