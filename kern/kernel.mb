#include "defines.mh"
#include "list.mb"

// Don't do this at home, kids.
#include "stdlib.mb"
#include "early_alloc.mb"
#include "buddy_alloc.mb"
#include "slab_alloc.mb"
#include "locks/mut.mb"
#include "structures/tcb.mb"
#include "structures/schedule.mb"
#include "locks/cond.mb"
#include "locks/sem.mb"
#include "locks/rw.mb"
#include "context/context.mb"
#include "structures/VM.mb"
// #include "threadstuffs/repl.mb"

/*** Helpful register functions ***/
extern fn get_cr0() -> u32;
extern fn get_cr3() -> u32;
extern fn get_cr4() -> u32;
extern fn set_cr0(val: u32);
extern fn set_cr3(val: u32);
extern fn set_cr4(val: u32);

fn hello(n: *u8) {
    let i: u32 = 0;
    while(true) {
        i+=1;
        if (i == 9000) {
          printf1_("Thread %u: \"goodbye!\"\n", get_tcb()->tid);
          scheduler_update(DESC);
        }

        printf1_("Thread %x: \"hello!\"\n", n as u32);
        scheduler_update(-1);
    };
}

fn reply() {
    while(true) {
        printf1_("Thread %u: \"WHAT?\"\n", get_tcb()->tid);
        scheduler_update(-1);
    };
}

fn kernel_main() -> u32 {
    /*** Basic util initialization ***/
    frame_init();
    slub_init();
    
    let var: u32 = 5;
    /*** Create two threads and schedule them ***/
    let new_tcb: *tcb = thr_create(&hello as *u8, &var as *u8, 4);
    assert(new_tcb != null);
    schedule(new_tcb, FRONT);

    let new_tcb2: *tcb = thr_create(&reply as *u8, null, 0);
    assert(new_tcb2 != null);
    schedule(new_tcb2, BACK);

    /*** Create an initial page directory and enable paging ***/
    let PD: *PD_t = frame_alloc(0) as *PD_t; // should be sizeof() 
    assert(PD_init(PD) >= 0);

    load_PD(PD);
    enable_paging(); 

    /*** Switch to the first thread in the run queue and jump to its execution ***/
    scheduler_update(-1);
    while (true) {};
    0
}
