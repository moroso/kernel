/* interface and implementation of the ipc descriptor table, which translates
 * ipc descriptors to mailbox ids kernel-side.  There is one descriptor table
 * per proc 
 *
 * Author Amanda M. Watson
*/


use structures::tcb::*;
use utils::stdlib::*;
use structures::schedule::*;
use structures::tcb_dir::*;
use locks::mutex::*;
use structures::mailbox::*;
use locks::lol_atomics::*;
use structures::proc::*;

const MB_TABLE_SIZE: u32 = 64; // number of descriptors in the table

struct mb_desc_table {
    desc_table: (*mailbox_t)[MB_TABLE_SIZE],
    mut: kmut,
}

fn mb_desc_init(table: *mb_desc_table, parent_proc: *proc) {
    if (parent_proc == null) {
        mos_memset(&(table->desc_table)[0], 0, sizeof(*mailbox_t) * MB_TABLE_SIZE);    
    } else {
        mos_memcpy(&(table->desc_table)[0],
                &(parent_proc->mb_desc.desc_table)[0], MB_TABLE_SIZE * sizeof(*mailbox_t));
    }
    kmut_init(&table->mut);
}

fn get_ipc_dest(id: u32) -> *mailbox_t {
    let proc = get_tcb()->proc;
    if (id >= MB_TABLE_SIZE) {
        return null;
    }
    assert!(proc != null);
    let table = &(proc->mb_desc);
    kmut_lock(&table->mut);
    let mb = table->desc_table[id];    
    kmut_unlock(&table->mut);
    mb
}

// add mailbox to descriptor table, return descriptor.  returns failure if all
// descriptor slots are taken
fn mb_table_add(table: *mb_desc_table, mb: *mailbox_t) -> i32 {
    kmut_lock(&table->mut); 
    let i: u32;
    for (i = 0; i < MB_TABLE_SIZE; i+=1) {
        if (table->desc_table[i] == null) {
            (table->desc_table)[i] = mb;
            atomic_add(&mb->ref_count, 1);
            kmut_unlock(&table->mut); 
            return i as i32;
        }
    }
    kmut_unlock(&table->mut); 
    -1
}

// desc ref counts on all mailboxes in descriptor table.  free any that no
// longer have a reference
// NOTE if the only way references can be added is by repls and forwarding, we
// don't have to worry about references being added is we're the last one (I
// mean, in the same way COW does)
fn mb_table_destroy(table: *mb_desc_table) {
    kmut_lock(&table->mut); 
    let i: u32;
    for (i = 0; i < MB_TABLE_SIZE; i+=1) {
        if (table->desc_table[i] != null) {
            let mb = table->desc_table[i];
            let last_count = atomic_add(&mb->ref_count, -1);
            if (last_count == 1) {
                mb_destroy(mb);
            }
            kmut_unlock(&table->mut); 
        }
    }
    kmut_unlock(&table->mut); 
}
