/* interface and implementation of the mailbox descriptor table, which translates
 * ipc descriptors to mailbox ids kernel-side.  There is one descriptor table
 * per proc 
 *
 * Author Amanda M. Watson
*/

use structures::tcb::*;
use utils::stdlib::*;
use structures::schedule::*;
use structures::tcb_dir::*;
use locks::mutex::*;
use structures::mailbox::*;
use locks::lol_atomics::*;
use structures::proc::*;

const MB_TABLE_SIZE: u32 = 64; // number of descriptors in the table

struct mb_desc_table {
    desc_table: (*mailbox_t)[MB_TABLE_SIZE],
    mut: kmut,
}

/* Initializes an mb_desc_table; if there is a parent_proc, copies its
 * descriptor translations; otherwise, sets all table indices to null.
*/
fn mb_desc_init(table: *mb_desc_table, parent_proc: *proc) {
    kmut_init(&table->mut);
    if (parent_proc == null) {
        mos_memset(&(table->desc_table)[0], 0, sizeof(*mailbox_t) * MB_TABLE_SIZE);    
    } else {
        let i: u32;
        let child_table = table; 
        let parent_table =  &(parent_proc->mb_desc);
        kmut_lock(&parent_table->mut);
        for (i = 0; i < MB_TABLE_SIZE; i+=1) {
            child_table->desc_table[i] = null;
            if (parent_table->desc_table[i] != null) {
                assert!(mb_table_add(child_table, parent_table->desc_table[i])
                        >= 0);
            } 
        }
        kmut_unlock(&parent_table->mut);
    }
}

/* given a mailbox descriptor, returns corresponding entry in table.  returns 
 * null if id cannot be a valid descriptor */
fn mb_desc_lookup(id: u32) -> *mailbox_t {
    let proc = get_tcb()->proc;
    if (id >= MB_TABLE_SIZE || id < 0) {
        return null;
    }
    assert!(proc != null);
    let table = &(proc->mb_desc);
    kmut_lock(&table->mut);
    let mb = table->desc_table[id];    
    kmut_unlock(&table->mut);
    mb
}

// add mailbox to descriptor table, return descriptor.  returns failure if all
// descriptor slots are taken
fn mb_table_add(table: *mb_desc_table, mb: *mailbox_t) -> i32 {
    kmut_lock(&table->mut); 
    let i: u32;
    for (i = 0; i < MB_TABLE_SIZE; i+=1) {
        if (table->desc_table[i] == null) {
            (table->desc_table)[i] = mb;
            atomic_add(&mb->ref_count, 1);
            kmut_unlock(&table->mut); 
            return i as i32;
        }
    }
    kmut_unlock(&table->mut); 
    -1
}

// desc ref counts on all mailboxes in descriptor table.  free any that no
// longer have a reference
// NOTE if the only way references can be added is by repls and forwarding, we
// don't have to worry about references being added is we're the last one 
fn mb_table_destroy(table: *mb_desc_table) {
    kmut_lock(&table->mut); 
    let i: u32;
    for (i = 0; i < MB_TABLE_SIZE; i+=1) {
        if (table->desc_table[i] != null) {
            let mb = table->desc_table[i];
            let last_count = atomic_add(&mb->ref_count, -1);
            if (last_count == 1) {
                mb_destroy(mb);
            }
            kmut_unlock(&table->mut); 
        }
    }
    kmut_unlock(&table->mut); 
}
