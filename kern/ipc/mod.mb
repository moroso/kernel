/* ipc/mod.mb
 * Contains implementation of ipc request primitives, such as send and recv 
 *
 * Implementation is currently synchronous, and moves unshared pages
 * TODO timeouts, async, fast path, reply, shared memory
 *
 * Author: Amanda M. Watson
*/

use structures::tcb_dir::*;
use structures::proc_dir::*;
use locks::mutex::*;
use locks::cond::*;
use consts::STATE_DEAD;
use structures::schedule::get_tcb;
use structures::VM::{is_user_addr, page_transfer, log_to_phys};
use locks::rendezvous::*;
use consts::*;
use utils::stdlib::*;
use utils::slab_alloc::*;
use utils::string::*;


extern fn get_cr3() -> u32;

struct message_node {
    long_addr: *u8,
    long_len: u32,
    message: *u8,
    message_len: u32,
}

/*
 * given a valid source buffer and an active tid, sends a source long_src with
 * length len_long to thread id.  currently synchronous: acting tcb will
 * deschedule until tcb tid is ready to receive.  If sending tcb is called while
 * tcb id is waiting, it will perform the transfer itself. If not, it
 * deschedules with a message, and relies on the receiver to perform the
 * transfer.  
 *
 * Requires that long_src be mapped in and be a user address 
 * Transfer removes mapping ar addr src and stores the frames at long_dest
 * Returns successful length of section copied, a negative error
 * value otherwise 
 *
 * id: currently the TID of the receiving tcb
 * long_src: the address at which the starting soure frame is mapped
 * message: not sure yet.  a message of some sort for the receiver
 * len_long: maximum length of transfer in bytes
 * timeout: time (in ms) before we return failure 
*/
fn ipc_send(id: u32, long_src: *u8, message: **u32, len_long: u32, len_short: *u32, timeout: u32) -> i32 {
    /* we're not currently reading in these args from userspace, so we set them
     * here */
    len_long = 4096; 
    timeout = 0; 

    if (!is_user_addr(long_src)) {
        return -3;
    }  

    // we are assuming some arg validation
    let kernel_message: *u8 = slub_alloc(*len_short) as *u8;
    if (kernel_message == null && *len_short != 0) {
        return -8;
    }
    mos_strncpy(kernel_message, *message as *u8, *len_short);

    /* if source address isn't mapped in, return failure */
    let page: u32;
    for (page = 0; page < len_long + PAGE_SIZE; page+=PAGE_SIZE) {

        if (log_to_phys(long_src + page, &(get_tcb()->proc->PD)) == null) {
            return -7;
        }
    }

    /* find the receiving tcb -- it cannot go away as long as we're looking at
     * it */
    let tcb_recv = tcb_lookup(id);
    if (tcb_recv == null) {
        return -1;
    }

    // I think we're ok on the "what if receiver died?" thing, as we have
    // timeouts
    let new_message: message_node;
    new_message.long_addr = long_src as *u8;
    new_message.message = kernel_message;
    new_message.message_len = *len_short;
    new_message.long_len = len_long;

    let message_buf: *u32;
    let message_len: u32;

    let node_recv = rend_wait(&tcb_recv->ipc_rend, &new_message as *u32,
            sizeof(message_node), &message_buf, &message_len, timeout, SEND);

    // if it's null, this means we went to sleep before recv, and the transfer
    // was done and we got a reply 
    if (node_recv == null) {
        mos_strncpy(*message as *u8, message_buf as *u8, min(message_len,
                    *len_short));

        tcb_end_lookup(tcb_recv);
        // TODO check message to see if we timed out and should return failure

        return 0;
    } 

    let m_node = node_recv->message as *message_node;
    let recv_message = m_node->message;
    let recv_len = m_node->message_len;

    assert!(is_user_addr(m_node->long_addr));

    // do a lookup to make sure the address space is still intact
    // TODO figure out if receiver is dead, and proc might no longer exist 
    let proc_recv = tcb_recv->proc;
    // this ensures the proc won't go away as we do things to it

    if (proc_recv == null) {
        printf!("recipiant proc is dead: return with error\n"); 
        tcb_end_lookup(tcb_recv);
        return -4;
    }
    let transfer_len = min!(len_long as u32, m_node->long_len as u32);
    for (page = 0; page < transfer_len; page+=PAGE_SIZE) {
        if (page_transfer(long_src + page, m_node->long_addr + page, &(get_tcb()->proc->PD),
                    &(proc_recv->PD), 0) < 0) {
            printf!("problem in page transfer\n");
            tcb_end_lookup(tcb_recv);
            // TODO either put pages back or return a length
            return -5;
        }
    }

    // TODO compose message as response

    rend_signal(kernel_message as *u32, *len_short, node_recv, SEND);

    // we are assuming some arg validation
    mos_strncpy(*message as *u8, recv_message, *len_short);
    slub_free(recv_message as *u32, recv_len);


    tcb_end_lookup(tcb_recv);

    transfer_len as i32
}

/* 
 * receives a number of pages up to len_long bytes, mapped in starting with address
 * long_dest.  If a sender is waiting to send, retrieves their info and performs
 * the transfer.  Otherwise, deschedules until a sender becomes available and
 * does the transfer itself.  Returns the number of bytes copied on success,
 * negative error code on failure
 *
 * Requires long_dest be a userland address
 *
 * long_dest: userspace address where new pages are to be mapped in
 * message: not sure yet
 * len_long: length of transfer, not of mesage
 * timeout: time (in ms) before we give up waiting and return failure
 */
fn ipc_recv(long_dest: *u8, message: **u32, len_long: u32, len_short: *u32, timeout: u32) -> i32 {
    len_long = 4096 * 2;

    if (!is_user_addr(long_dest)) {
        return -3;
    }  

    // this gets encapsulated in user mem validation
    let kernel_message: *u8 = slub_alloc(*len_short) as *u8;
    if (kernel_message == null && *len_short != 0) {
        return -8;
    }
    mos_strncpy(kernel_message, *message as *u8, *len_short);


    let tcb_recv = get_tcb();
    assert!(tcb_recv != null);

    let new_message : message_node;
    new_message.long_addr = long_dest;
    new_message.message = kernel_message;
    new_message.message_len = *len_short;
    new_message.long_len = len_long;

    let message_buf: *u32;
    let message_len: u32;
    let node_send = rend_wait(&tcb_recv->ipc_rend, &new_message as *u32,
            sizeof(message_node), &message_buf, &message_len, timeout, RECV);

    if (node_send == null) {
        mos_strncpy(*message as *u8, message_buf as *u8, min(message_len,
                    *len_short));

        // TODO make sure this can't be a success case; only for timeouts
        if (message_buf == null) {
            return -2
        }

        return 0;
    }

    let m_node = node_send->message as *message_node;
    let send_message = m_node->message;
    let send_len = m_node->message_len;

    assert!(is_user_addr(m_node->long_addr));

    let transfer_len = min!(len_long as u32, m_node->long_len as u32);

    let page: u32;
    for (page = 0; page < transfer_len; page+=PAGE_SIZE) {
        if (page_transfer(m_node->long_addr + page, long_dest + page,
                    &(node_send->tcb->proc->PD), &(get_tcb()->proc->PD), 0) < 0) {

            printf!("problem in page transfer\n");
            // TODO either put pages back or return a length
            return -1;
        }
    }

    // TODO compose message as response

    rend_signal(kernel_message as *u32, *len_short, node_send, RECV);

    // this gets encapsulated in user mem validation
    mos_strncpy(*message as *u8, send_message, min(*len_short, send_len));
    slub_free(send_message as *u32, send_len);
    transfer_len as i32
}


/* replies to the given id with a synchronous message */
fn reply(id: u32) {


}


