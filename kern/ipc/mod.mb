/* ipc/mod.mb
 * Contains implementation of ipc request primitives, send, recv and reply 
 * 
 * Author: Amanda M. Watson
*/

use structures::tcb_dir::*;
use structures::tcb::*;
use structures::proc_dir::*;
use locks::mutex::*;
use locks::cond::*;
use consts::STATE_DEAD;
use structures::schedule::*;
use structures::VM::{PD_t, is_user_addr, page_transfer, log_to_phys, is_addr_aligned};
use locks::rendezvous::*;
use consts::*;
use utils::stdlib::*;
use utils::slab_alloc::*;
use utils::string::*;
use utils::user_mem::*;
use utils::list::*;
use entry::get_ticks;
use structures::mailbox::*;
use shared::ipc_defs::*;
mod desc_table;

/* instructs a thread receiving the invoker on how to conduct the transfer.
 * Receiver may alter fields to denote how much memory is transferred to the
 * destination */
struct message_node {
    long_src: buffer_t,
    long_dest: buffer_t, 
    short_src: buffer_t,
    /* mailbox being sent to destination */
    mailbox_src: *mailbox_t,
    /* descriptor sent from destination */
    desc_dest: i32,
    /* used by the sender to denote their option */
    options: u32,
    err: u32,
}

// size of buffer we're willing to put on the stack for short messages
const SHORT_BUFFER_MAX: u32 = 200;

/* places long message in destination PD, returns length transferred */
fn transfer_long(PD_src: *PD_t, addr_src: *u8, len_src: u32, PD_dest: *PD_t,
        addr_dest: *u8, len_dest: u32, shared: u32) -> u32 {
    /*** transfer long message ***/
    let transfer_len = min!(len_src, len_dest);
    if (transfer_len == 0) {
        return 0;
    }
    kmut_2lock(&(PD_src->mut), &(PD_dest->mut));

    let page: u32;
    for (page = 0; page < transfer_len; page+=PAGE_SIZE) {
        if (page_transfer(addr_src + page,
                    addr_dest + page,
                    PD_src,
                    PD_dest, shared) < 0) {
            transfer_len = max(0, page - PAGE_SIZE);
            break;
        }
    }
    kmut_2unlock(&(PD_src->mut), &(PD_dest->mut));

    transfer_len
}


/* ipc_send: sends a long and/or short message to an active recipiant
 * arguments are passed in the form of the 'args' struct: 
 * 
 * - dest_id: the mailbox descriptor being sent to.  function returns ERR_DEST if
 * dest_id is not a valid descriptor 
 * - long_src: specifies the long message to be passed to the recipiant.  A
 *    maximum of long_src.len bytes will be copied to the recipiant.  long_src.addr
 *    is ignored if long_src.len is 0.  returns success (but with no copy) if pages
 *    are not mapped at the time of the copy.  returns ERR_ARGS if long_src.len is 
 *    not page aligned. Ignored if message is async.
 * - long_dest: specifies a buffer for a long reply from receiver.
 *    long_dest.len gets altered to be the final length of the message copied.  ignored if
 *     message is async or doesn't expect a reply
 * - short_src: specifies a short message to be passed to the recipiant.  A
 *    maximum of short_src.len bytes will be copied to the recipiant.
 *    short_src.addr is ignored if short_src.len is 0.  returns ERR_ARGS if
 *     short_src.len is larger than PAGE_SIZE
 * - short_dest: specifies a buffer for a short reply from receiver.  Is ignored
 *    if send doesn't expect a reply.  A maximum of short_dest.len bytes is copied;
 *    short_dest.len is altered to specify number of bytes copied to
 *    short_dest.addr
 * - timeout: how many clock cycles a message should wait for receipt/reply
 *    until it expires.  message is unable to timeout while being modified by
 *    ipc_recv or ipc_reply.  a timeout of -1 means the message does not expire
 * - option specifies what kind of message (async, sync_reply, sync_noreply) and
 *    whether long message is shared
 *
 * If the receiver is waiting and no reply is expected, the invoking thread will
 * perform the transfer and wake up the receiver; else, the receiver performs
 * the transfer and wakes up the invoking thread after.  If a reply is expected,
 * the sender blocks until it is collected by a receiver, or it times out.
 *
 * Returns 0 on success, a negative error code on error.  the dest fields in
 * args are altered to denote how much was copied to the specified buffers.
 * Note that message transfers might still be successful, even if a negative
 * error code is returned
 */
fn ipc_send(args: *ipc_args) -> i32 {

    /* copying arguments into the kernel */   
    let args_kern: ipc_args;
    if (copy_from_user((&args_kern) as *u8, args as *u8, sizeof(ipc_args)) < 0) {
        return IPC_ERR_INTERNAL;
    } 

    /* identifying send options for internal IPC */ 
    let option: u32 = SEND_SYNC_REPLY;
    if (args_kern.options&OPTION_ASYNC != 0) {
        option = SEND_ASYNC;
    } else if (args_kern.options&OPTION_NO_REPLY != 0) {
        option = SEND_SYNC_NOREPLY;
    }

    /* if we're async, ignore long arguments */
    if (option == SEND_ASYNC) {
        args_kern.long_src.len = 0;
        args_kern.long_dest.len = 0;
    }

    let shared: u32 = args_kern.options&OPTION_SHARE;
    

    /* if the message is short and needs a reply (meaning we're asleep until the
     * receiver copies us to userspace), place a manageable short message on the
     * stack.  Otherwise, dynamically allocate (we can save this for noreplies
     * when we do the fast path) */ 
    let short_message: *u32 = null;
    if (args_kern.short_src.len > 0) {
        if (option == SEND_SYNC_REPLY && args_kern.short_src.len <
                SHORT_BUFFER_MAX) {
            let short_message_temp: u32[SHORT_BUFFER_MAX];
            short_message = &short_message_temp[0];
        } else {
            short_message = slub_alloc(args_kern.short_src.len); 
        }
        if (short_message == null || copy_from_user(short_message as *u8,
                    args_kern.short_src.addr,
                    args_kern.short_src.len) < 0) {
            return IPC_ERR_INTERNAL;
        }
    }

    // check to see if addresses all point to user addresses
    if ((!is_user_addr(args_kern.long_src.addr) && args_kern.long_src.len > 0) ||
            (!is_user_addr(args_kern.long_dest.addr)  && args_kern.long_dest.len > 0)  ||
            (!is_user_addr(args_kern.short_src.addr)  && args_kern.short_src.len > 0) ||
            (!is_user_addr(args_kern.short_dest.addr))  && args_kern.short_dest.len > 0)  {
        return IPC_ERR_ARGS;  
    }

    /* ensures long addresses are page aligned */
    if ((!is_addr_aligned(args_kern.long_src.addr) && args_kern.long_src.len > 0)||
            (!is_addr_aligned(args_kern.long_dest.addr)) && args_kern.long_dest.len > 0)  {
        return IPC_ERR_ARGS;  
    }

    /* ensures short message is smaller than page */
    if (args_kern.short_src.len > PAGE_SIZE) {

        return IPC_ERR_ARGS;
    }

    /* ensures long lengths are multiples of page sizes */
    if (args_kern.long_src.len%PAGE_SIZE != 0 ||
            args_kern.long_dest.len%PAGE_SIZE != 0)
    {
        return IPC_ERR_ARGS;
    }    

    /*** create message that relays ipc info to receiver ***/
    let message_send: message_node;
    mos_memcpy(&message_send.long_src, &args_kern.long_src, sizeof(buffer_t));
    mos_memcpy(&message_send.long_dest, &args_kern.long_dest, sizeof(buffer_t));

    message_send.short_src.addr = short_message as *u8;
    message_send.short_src.len = args_kern.short_src.len;
    message_send.options = args_kern.options; 

    /* the mailbox being forwarded to the destination */
    let mailbox_fwd = desc_table::mb_desc_lookup(args_kern.desc_src as
            u32);
    message_send.mailbox_src = mailbox_fwd; 

    let message_recv: *u8;
    let recv_len: u32;
    let err: i32 = 0;

    let dest_tcb = mb_send(args_kern.dest_id, 
            &message_send as *u32, sizeof(message_node),
            &message_recv as **u32,
            &recv_len, 
            args_kern.timeout, option, &err);  

    /* end the lookup for now -- we will re-do it on the actual transfer */
    desc_table::mb_end_lookup(mailbox_fwd);

    /*** if there was an error during the process, return ***/
    if (err < 0) {

        if (err == MB_ERR_DEST) {
            return IPC_ERR_DEST;
        }

        if (err == MB_ERR_OWNER) {
            return IPC_ERR_DEST;
        }

        if (err == REND_ERR_TIMEOUT) {
            return IPC_ERR_TIMEOUT;
        }

        // if tcb died before we could transfer, return with error
        if (err == REND_ERR_DEAD) {

            return IPC_ERR_DEAD;
        }

        return IPC_ERR_INTERNAL;
    }

    // if we have no tcb and no error, this means the full transfer
    // occurred on the other side; clean up and return
    if (dest_tcb == null) {
        args_kern.desc_dest = message_send.desc_dest;
        /* receiver already transferred long message, so update length */
        args_kern.long_dest.len = message_send.long_dest.len;

        /* copy receiver's short reply to userland */
        args_kern.short_dest.len = min(recv_len, args_kern.short_dest.len);
        if (copy_to_user((args_kern.short_dest.addr), message_recv as *u8,
                    min(recv_len, args_kern.short_dest.len)) <
                0) {

            return IPC_ERR_INTERNAL;
        }

    } else {

        /* if we have a message, this means the receiver is sleeping, and we
         * perform the transfer ourselves 
         *
         * note that this also means that we will need to call mb_end_send
         * before we exit to make sure the sleeping receiver is woken up/handed
         * the short message (this includes in the error cases)
         */
        let message_dest: *message_node = message_recv as *message_node;

        message_dest->options = args_kern.options;

        if ((mailbox_fwd = desc_table::mb_desc_lookup(args_kern.desc_src as
                        u32)) != null) {
            let proc_dest = dest_tcb->proc;
            assert!(proc_dest != null);
            message_dest->desc_dest = desc_table::mb_table_add(&proc_dest->mb_desc, mailbox_fwd);
            desc_table::mb_end_lookup(mailbox_fwd);
        }
        if (message_dest->long_dest.len > 0) {

            assert!(dest_tcb != null);
            /* in our current system, all active tcbs must have an active proc.
             * Thus, we don't need to increment the ref count  */
            let proc_recv = dest_tcb->proc;
            assert!(proc_recv != null);

            /*** transfer long message ***/
            let transfer_len = transfer_long(&(get_tcb()->proc->PD),
                    args_kern.long_src.addr, args_kern.long_src.len, &(proc_recv->PD),
                    message_dest->long_dest.addr,
                    message_dest->long_dest.len, shared);

            message_dest->long_dest.len = transfer_len;
        } 

        /*** transfer short message and wake up receiver ***/
        mb_end_send(short_message, args_kern.short_src.len, 0);
    }

    if (copy_to_user(args as *u8, &args_kern as *u8, sizeof(ipc_args)) <
            0) {

        return IPC_ERR_INTERNAL;
    }

    0
}

/* ipc_recv: receives a number of pages up to len_long bytes, mapped in starting with address
 * long_dest.  If a sender is waiting to send, retrieves their info and performs
 * the transfer.  Otherwise, deschedules until a sender becomes available and
 * does the transfer itself.  
 *
 * Arguments are passed in an ipc_args struct.  Their fields are the following: 
 *
 * - dest_id: the mailbox descriptor being sent to.  function returns ERR_DEST if
 *   dest_id is not a valid descriptor or if the invoking thread is not an owner 
 * - long_src: ignored for recv
 * - long_dest: specifies a buffer for a long message from the sender
 *    long_dest.len gets altered to be the final length of the message copied. 
 * - short_src: Ignored for recv
 * - short_dest: specifies a buffer for a short message from sender.  
 *    A maximum of short_dest.len bytes is copied;
 *    short_dest.len is altered to specify number of bytes copied to
 *    short_dest.addr
 * - timeout: how many clock cycles a message should wait for receipt
 *    until it expires.  message is unable to timeout while being modified by
 *    ipc_send.  a timeout of -1 means the message does not expire
 * - option retrieves senders sending preferences 
 *
 * If the sender is already waiting, the invoking thread will
 * perform the transfer and wake up the sender; else, the sender performs
 * the transfer and wakes up the invoking thread after.  
 *
 * Returns 0 on success, a negative error code on error.  the dest fields in
 * args are altered to denote how much was copied to the specified buffers.
 * Note that message transfers might still be successful, even if a negative
 * error code is returned
 * 
 * function immediately returns error if the last received thread with a reply
 * option has not been replied to
 */

fn ipc_recv(args: *ipc_args) -> i32 {

    let args_kern: ipc_args;
    let enable = cond_preempt_disable();
    /* if a thread has been received by the invoking thread and is awaiting a
     * reply, return with error */
    if (!list_is_empty(&get_tcb()->last_send)) {
        cond_preempt_enable(enable);
        return IPC_ERR_REPLY;
    }
    cond_preempt_enable(enable);

    /* copy args to kernel */
    if (copy_from_user((&args_kern) as *u8, args as *u8, sizeof(ipc_args)) < 0) {
        return IPC_ERR_INTERNAL;
    }

    // check to see if addresses all point to user addresses
    if ((!is_user_addr(args_kern.long_dest.addr)  && args_kern.long_dest.len > 0)  ||
            (!is_user_addr(args_kern.short_dest.addr))  && args_kern.short_dest.len > 0)  {
        return IPC_ERR_ARGS;  
    }

    // ensures long addresses are page aligned
    if ((!is_addr_aligned(args_kern.long_dest.addr)) && args_kern.long_dest.len > 0)  {
        return IPC_ERR_ARGS;  
    }

    // ensures long lengths are multiples of page sizee 
    if (args_kern.long_dest.len%PAGE_SIZE != 0)
    {
        return IPC_ERR_ARGS;
    }    

    /* create message to send to sender */
    let message_send: message_node;
    mos_memcpy(&message_send.long_dest, &args_kern.long_dest, sizeof(buffer_t));

    let message_recv: *u8;
    let recv_len: u32;
    let err: i32 = 0;
    let send_option: u32;

    let dest_tcb = mb_recv(args_kern.dest_id, 
            &message_send as *u32, sizeof(message_node),
            &message_recv as **u32, &recv_len, 
            args_kern.timeout, &send_option, &err);  

    // if recv had an error, return with err
    if (err < 0) {

        if (err == MB_ERR_DEST) {
            return IPC_ERR_DEST;
        }

        if (err == MB_ERR_OWNER) {
            return IPC_ERR_DEST;
        }

        if (err == REND_ERR_TIMEOUT) {
            return IPC_ERR_TIMEOUT;
        }

        // if tcb died before we could transfer, return with error
        if (err == REND_ERR_DEAD) {
            return IPC_ERR_DEAD;
        }

        return IPC_ERR_INTERNAL;
    }

    // if we have no message and no error, this means the full transfer
    // occurred; clean up and return
    if (dest_tcb == null) {
        // new length written into message (sender updates this length)
        args_kern.options = message_send.options;
        args_kern.desc_dest = message_send.desc_dest;
        args_kern.long_dest.len = message_send.long_dest.len;
        args_kern.short_dest.len = min(args_kern.short_dest.len,
                recv_len);
        if (copy_to_user((args_kern.short_dest.addr), message_recv as *u8,
                    args_kern.short_dest.len) <
                0) {
            return IPC_ERR_INTERNAL;
        }
    } else {
        /* otherwise, we perform the transfer ourselves */
        let message_src: *message_node = message_recv as *message_node;
        args_kern.options = message_src->options;
        if (message_src->mailbox_src != null) {
            let proc_dest = dest_tcb->proc;
            assert!(proc_dest != null);
            args_kern.desc_dest =
                desc_table::mb_table_add(&(get_tcb()->proc->mb_desc),
                        message_src->mailbox_src);
        }


        let transfer_len = min!(message_src->long_src.len, args_kern.long_dest.len);
        if (transfer_len > 0) {
            assert!(send_option != SEND_ASYNC);
            assert!(dest_tcb != null);
            kmut_2lock(&(get_tcb()->proc->PD.mut), &(dest_tcb->proc->PD.mut));
            let page: u32;
            for (page = 0; page < transfer_len; page+=PAGE_SIZE) {
                if (page_transfer(message_src->long_src.addr + page,
                            args_kern.long_dest.addr + page,
                            &(dest_tcb->proc->PD), 
                            &(get_tcb()->proc->PD),
                            message_src-> options&OPTION_SHARE) < 0) {
                    transfer_len = max(0, page - PAGE_SIZE);
                    break;
                }
            }
            kmut_2unlock(&(get_tcb()->proc->PD.mut), &(dest_tcb->proc->PD.mut));

        }

        args_kern.short_dest.len = min(args_kern.short_dest.len,
                message_src->short_src.len);
        args_kern.long_dest.len = transfer_len;

        if (copy_to_user((args_kern.short_dest.addr),
                    message_src->short_src.addr as *u8,
                    args_kern.short_dest.len) <
                0) {

            mb_end_recv(IPC_ERR_INTERNAL);
            return IPC_ERR_INTERNAL;
        }
        if (message_src->short_src.len > 0 &&
                message_src->options&(OPTION_NO_REPLY | OPTION_ASYNC) == 0 &&
                message_src->short_src.len > SHORT_BUFFER_MAX) {
            slub_free(message_src->short_src.addr as *u32,
                    message_src->short_src.len);
        } 


        mb_end_recv(0);
    }

    if (copy_to_user(args as *u8, &args_kern as *u8, sizeof(ipc_args)) <
            0) {

        return IPC_ERR_INTERNAL;
    }

    0
}


/* reply: replies to the last sender received by invoking thread; returns with error if no active thread
 * awaits a reply  
 * 
 * - message_long: address of long message to send to receiver.  returns with
 *                 success (but mapping fails) if address in range becomes unmapped
 * - long_len: maximum length of long message transfer.  message_long is ignored
 *   if long_len is 0.  
 * - message_short: address of short message to send to receiver. 
 * - short_len: maximum length of short message.  message_short is ignored if short_len
 *   is 0.
 * - desc: descriptor being sent to sender
 *
 * Returns 0 on success, negative error code of failure.  
 *
 * TODO hide rend manipulation behind a layer of abstraction, as with the other
 * functions
 */
fn reply(message_long: *u8, long_len: u32, message_short: *u32, short_len: u32,
        desc: i32) -> i32 {

    // check to see if addresses all point to user addresses
    if ((!is_user_addr(message_long as *u32)  && long_len > 0)  ||
            (!is_user_addr(message_short)  && short_len > 0))  {
        return IPC_ERR_ARGS;  
    }

    /* ensures long addresses are page aligned */
    if (!is_addr_aligned(message_long) && long_len > 0)  {
        return IPC_ERR_ARGS;  
    }

    /* ensures short message is smaller than page */
    if (short_len > PAGE_SIZE) {
        return IPC_ERR_ARGS;
    }

    /* ensures long lengths are multiples of page sizes */
    if (long_len%PAGE_SIZE != 0) {
        return IPC_ERR_ARGS;
    }    

    let enable = cond_preempt_disable();
    if (list_is_empty(&get_tcb()->last_send)) {
        cond_preempt_enable(enable);
        return IPC_ERR_REPLY;
    }

    let last_send: *rend_node = list_head_entry!(&get_tcb()->last_send, rend_node,
            rend_link);
    assert!(last_send != null);
    last_send->can_timeout = false;
    list_del(&last_send->rend_link);
    cond_preempt_enable(enable);

    let message_src: *message_node = last_send->message as *message_node;
    if (desc >= 0) {
        let mailbox_fwd = desc_table::mb_desc_lookup(desc as
                u32);
        message_src->desc_dest = desc_table::mb_table_add(&last_send->tcb->proc->mb_desc, 
                mailbox_fwd);

        desc_table::mb_end_lookup(mailbox_fwd);
        if (message_src->desc_dest < 0) {
            rend_signal(null, 0, last_send, IPC_ERR_MB);
            return IPC_ERR_MB;
        }
    }

    /* long message transfer */
    let transfer_len = transfer_long(&(get_tcb()->proc->PD), message_long, long_len, 
            &(last_send->tcb->proc->PD), message_src->long_dest.addr, message_src->long_dest.len, 0);
    message_src->long_dest.len = transfer_len;

    let message_kernel = null;
    if (short_len > 0) {
        message_kernel = slub_alloc(short_len);
        if (message_kernel == null || copy_from_user(message_kernel as *u8,
                    message_short as *u8,
                    short_len) < 0) {


            rend_signal(message_kernel, short_len, last_send, 0);
            return IPC_ERR_INTERNAL;
        }
    }

    rend_signal(message_kernel, short_len, last_send, 0);

    0
}
