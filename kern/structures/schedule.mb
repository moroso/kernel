/** schedule.mb: contains implementation of scheduler functions
  * Currently, there isn't much of a scheduler: you can schedule and 
  * deschedule things on/off the run queue, but the scheduler has no notion of
  * who's running.  Some design is in order.
  *
  * All scheduler functions will require preemption being disabled
  *
  * Author: Amanda M. Watson
  */
#include "schedule.mh"

/* 
 * global data structure: controls the run queue of runnable tcb's, 
 * denotes the tcb that is currently running, and whether preemption is enabled 
 */
static run_queue: rq_master = rq_master {
    head: LIST_HEAD_INIT(run_queue.head), 
    running: null,
    preempt_enabled: 0
}; 

fn preempt_disable() {
    run_queue.preempt_enabled = 0;
}

fn preempt_enable() {
    run_queue.preempt_enabled = 1;
}

fn is_preempt_enabled() -> u32 {
    run_queue.preempt_enabled
}

/* 
 * add a tcb to the run queue: position should be FRONT if tcb should be run immediately,
 * BACK if it should patiently wait its turn in the queue. 
 * Requires that tcb's state be set to NEW or RUNNABLE before insertion, so the
 * scheduler knows you really mean it.
 */
fn schedule(tcb: *tcb, pos: u32) {
    assert(is_preempt_enabled() == 0);
    
    if (tcb->state == NEW) {
        set_state(tcb, RUNNABLE);
    }
    assert(tcb->state == RUNNABLE);
    if (pos == FRONT) {
        list_insert_head(&tcb->link, &(run_queue.head));
        return ();
    } 
    if (pos == BACK) {
        list_insert_tail(&tcb->link, &(run_queue.head));
        return ();
    }
    // pos should specify either the front or back position 
    assert(false);
}

/* Remove a tcb from the run queue */
fn unschedule(tcb: *tcb) {
    assert(is_preempt_enabled() == 0);
    assert(tcb->state == RUNNABLE);
    list_del(&(tcb->link))
} 

/* returns pointer to running tcb: later if we have aligned memory we can find it via TCB; for now, we keep
   a pointer in the scheduler */
fn get_tcb() -> *tcb {
    run_queue.running 
}
