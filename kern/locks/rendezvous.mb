use locks::mutex::*;
use structures::tcb::*;
use utils::list::*;
use structures::schedule::*;
use consts::*;
use utils::slab_alloc::*;
use utils::stdlib::*;

const SEND_SYNC: u32 = 0;
const SEND_ASYNC: u32 = 2;
const RECV: u32 = 1;

struct rend_node {
    message: *u32,
    message_len: u32,
    tcb: *tcb,
    timeout: u32,
    timeout_link: list_node,
    rend_link: list_node,
    option: u32,
}

struct rend {
    send_head: list_head,
    recv_head: list_head,
}

fn rend_init(rend: *rend) {
    list_init_head(&rend->recv_head);
    list_init_head(&rend->send_head);
}

/* if an opposing node exists, grab it atomically and return it.  else, go to sleep
 * and wait for an opposing node to do the action and return null; in this case,
 * *message gets set to the message of the opposing node; else, message is null */
fn rend_wait(rend: *rend, message: *u32, message_len: u32, message_recv: **u32, recv_len: *u32, timeout: u32, option: u32) -> *rend_node {

    let enable = cond_preempt_disable();
    let other_head: *list_head;
    let own_head: *list_head; 

    let my_node: *rend_node; 
    if (option == SEND_SYNC) {
        let stack_node: rend_node;
        my_node = &stack_node;
    } else {
        my_node = slub_alloc(sizeof(rend_node)) as *rend_node;
        if (my_node == null) {
            return null; // TODO represent err 
        }
        let new_message = slub_alloc(message_len) as *u32;
        // TODO this policy is bad.  possible rend needs a better interface 
        if (new_message == null) {
            slub_free(my_node as *u32, sizeof(rend_node));
            return null // TODO err
        }
        mos_memcpy(new_message as *u8, message as *u8, message_len);
        message = new_message;
    }

    if (option == SEND_SYNC || option == SEND_ASYNC) {
        other_head = &rend->recv_head;
        own_head = &rend->send_head;
    } else {
        assert!(option == RECV);
        other_head = &rend->send_head;
        own_head = &rend->recv_head;
    }

    /* see if there is another node on the other side to grab */
    if (!list_is_empty(other_head)) {
        let other_node: *rend_node = list_head_entry!(other_head,
                rend_node, rend_link);
        assert!(other_node != null);
        list_del(&other_node->rend_link);
        cond_preempt_enable(enable);
        *message_recv = other_node->message;
        if (option == SEND_ASYNC) {
            slub_free(my_node as *u32, sizeof(rend_node));
            slub_free(message, message_len);
        }
        return other_node; // we allocate this on the stack, but it's asleep and direct-mapped, so we're ok
    } 


    my_node->timeout = timeout;

    if (option == SEND_SYNC) {
        my_node->tcb = get_tcb();
    }

    my_node->message = message;
    my_node->message_len = message_len;
    my_node->option = option;

    // TODO timeout queue
    list_insert_tail(&my_node->rend_link, own_head);

    if (option == SEND_SYNC) {
        scheduler_update(STATE_COND as i32);
    }
    *message_recv = my_node->message; 
    *recv_len = my_node->message_len;
    cond_preempt_enable(enable);

    null
}


/* give new message to rend_node and wake it up */
fn rend_signal(message: *u32, message_len: u32, rend_node: *rend_node) {
    if (rend_node->tcb == null) {
        if (rend_node->message != null) {
            slub_free(rend_node->message, rend_node->message_len); // TODO not this 
        }
        slub_free(rend_node as *u32, sizeof(rend_node));
        return ();
    }
    rend_node->message = message;
    rend_node->message_len = message_len;
    let enable = cond_preempt_disable();
    rend_node->tcb->state = STATE_RUNNABLE;
    schedule(rend_node->tcb, QUEUE_FRONT);

    // take ourselves off the run queue to be awoken with reply?
    cond_preempt_enable(enable);
}
