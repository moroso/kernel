use locks::mutex::*;
use structures::tcb::*;
use utils::list::*;
use structures::schedule::*;
use consts::*;

const SEND: u32 = 0;
const SEND_SYNC: u32 = 0;
const SEND_ASYNC: u32 = 0;
const RECV: u32 = 1;

struct rend_node {
    message: *u32,
    message_len: u32,
    tcb: *tcb,
    timeout: u32,
    timeout_link: list_node,
    rend_link: list_node,
}

struct rend {
    send_head: list_head,
    recv_head: list_head,
}

fn rend_init(rend: *rend) {
    list_init_head(&rend->recv_head);
    list_init_head(&rend->send_head);
}

/* if an opposing node exists, grab it atomically and return it.  else, go to sleep
 * and wait for an opposing node to do the action and return null; in this case,
 * *message gets set to the message of the opposing node; else, message is null */
fn rend_wait(rend: *rend, message: *u32, message_len: u32, message_recv: **u32, recv_len: *u32, timeout: u32, option: u32) -> *rend_node {

    let enable = cond_preempt_disable();
    let other_head: *list_head;
    let own_head: *list_head;

    if (option == SEND_SYNC || option == SEND_ASYNC) {
        other_head = &rend->recv_head;
        own_head = &rend->send_head;
    } else {
        assert!(option == RECV);
        other_head = &rend->send_head;
        own_head = &rend->recv_head;
    }

    if (!list_is_empty(other_head)) {
        let other_node: *rend_node = list_head_entry!(other_head,
                rend_node, rend_link);
        assert!(other_node != null);
        list_del(&other_node->rend_link);
        cond_preempt_enable(enable);
        *message_recv = other_node->message;
        return other_node; // we allocate this on the stack, but it's asleep and direct-mapped, so we're ok
    } 
    
    let my_node: rend_node;
    my_node.timeout = timeout;
    if (option == SEND_SYNC) {
        my_node.tcb = get_tcb();
    }
    my_node.message = message;
    my_node.message_len = message_len;

    // TODO timeout queue
    list_insert_tail(&my_node.rend_link, own_head);

    if (option == SEND_SYNC) {
        scheduler_update(STATE_COND as i32);
    }
    *message_recv = my_node.message; 
    *recv_len = my_node.message_len;
    cond_preempt_enable(enable);

    null
}


/* give new message to rend_node and wake it up */
fn rend_signal(message: *u32, message_len: u32, rend_node: *rend_node, option: u32) {
    assert!(rend_node->tcb != null);
    rend_node->message = message;
    rend_node->message_len = message_len;
    let enable = cond_preempt_disable();
    rend_node->tcb->state = STATE_RUNNABLE;
    schedule(rend_node->tcb, QUEUE_FRONT);

    // take ourselves off the run queue to be awoken with reply?
    cond_preempt_enable(enable);
}
