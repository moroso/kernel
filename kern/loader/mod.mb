/** loader/mod.mb 
 *
 *  contains the loader, used by the kernel to load user programs, and the
 *  exe header format.
 *
 *  TODO free VM on error, allocate MB as well as KB?
 *  Author: Amanda M. Watson
**/
use fs::fs_read;
use utils::slab_alloc::{slub_alloc, slub_free};
use utils::buddy_alloc::frame_alloc;
use consts::{USER_DS, USER_CS, PAGE_SIZE};
use structures::VM::{new_user_page, is_user_addr, READ_WRITE_BIT, KB};
use structures::schedule::get_tcb;
use entry::regs;
use utils::stdlib::mos_memcpy;


extern fn get_eflags() -> u32;

// Header for the bs executable file format
struct bsexe_header {
    magic: u8[4], // should be "MROE"
    binary_size: u32,
    mapping_size: u32,
    load_addr: u32,
    entry_point: u32
}


/* load a new program with name filename into the VM.  populates ureg with the
 * registers to pass to leave_kernel to load new program.  Returns with error if
 * file cannot be correctly loaded */
fn load(filename: *u8, ureg: *regs) -> i32 {
    assert!(ureg != null);
    
    let header: *bsexe_header = slub_alloc(sizeof(bsexe_header)) as
        *bsexe_header;

    if (header == null) {
        return -1;
    }

    if (fs_read(filename, header as *u8, sizeof(bsexe_header), 4) == -1) {
        slub_free(header as *u32, sizeof(bsexe_header));
        return -2;
    }

    let page_buf: *u8 = frame_alloc();
    if (page_buf == null) {
        slub_free(header as *u32, sizeof(bsexe_header));
        return -3;

    }

    let page_read: u32;
    
    // allocate an additional page for the user stack
    let user_esp = header->load_addr + header->mapping_size + PAGE_SIZE; 

    /* ensure that we can allocate the proper amount of space */
    for (page_read = header->load_addr; page_read < user_esp + PAGE_SIZE; 
            page_read+=PAGE_SIZE) {
        let new_page: *u8 = (page_read as *u8); 
        assert!(is_user_addr(new_page));
        if (new_user_page(new_page, &get_tcb()->proc->PD, 
                    READ_WRITE_BIT, KB) < 0) {

            // TODO remove prev allocated VM
            slub_free(header as *u32, sizeof(bsexe_header));
            return -4;
        } 

    }

    /* copy the binary data into VM */
    for (page_read = 0; page_read < header->binary_size + PAGE_SIZE; page_read+=PAGE_SIZE) {
        
        let length_read: u32 = fs_read(filename, page_buf, PAGE_SIZE,
                sizeof(bsexe_header) + page_read + 4) as u32;
        if (length_read == -1) {
            slub_free(header as *u32, sizeof(bsexe_header));
            // TODO remove prev allocated VM
            return -4;
        }

        let new_page: *u8 = header->load_addr + (page_read as *u8); 
        /* copy over the new data */
        mos_memcpy(new_page, page_buf, length_read);
    }


    /* Populate the ureg with the apporpriate info for running the file */
    ureg->esp = user_esp; // allocated in the for-loop 
    ureg->eip = header->entry_point;
    let eflags: u32 = get_eflags();
    ureg->eflags = eflags; // TODO do we have to set anything?
    ureg->ss = USER_DS; 
    ureg->ds = USER_DS;
    ureg->es = USER_DS;    
    ureg->cs = USER_CS;

    slub_free(header as *u32, sizeof(bsexe_header));

    0
}
