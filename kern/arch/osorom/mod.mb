use consts::PAGE_SIZE;
use structures::tcb::context;

mod drivers;
mod entry;
mod consts;
mod loader;
mod regs;
mod fs;

//TODO(porting): should probably increase this; we have a ton of registers!
const NUM_FASTPATH_REGS: u32  = 5; // number of GPRs being used in fastpath

extern "bare" fn enable_interrupts() {
    asm!("{ r0 <- PFLAGS; }"
         "{ r0 <- r0 | 1; }"
         "{ PFLAGS <- r0; }"
         "{ b r31 + 1; }");
}

extern "bare" fn disable_interrupts() {
    asm!("{ r0 <- PFLAGS; r1 <- ~1; }"
         "{ r0 <- r0 & r1; }"
         "{ PFLAGS <- r0; }"
         "{ b r31 + 1; }");
}

extern "bare" fn are_ints_enabled() -> bool {
    asm!("{ r0 <- PFLAGS; }"
         "{ b r31 + 1; r0 <- r0 & 1; }");
}

extern "bare" fn enable_paging() {
    asm!("{ r0 <- PFLAGS; }"
         "{ r0 <- r0 | 2; }"
         "{ PFLAGS <- r0; }"
         "{ b r31 + 1; }");
}

extern "bare" fn disable_paging() {
    asm!("{ r0 <- PFLAGS; r1 <- ~2; }"
         "{ r0 <- r0 & r1; }"
         "{ PFLAGS <- r0; }"
         "{ b r31 + 1; }");
}

extern "bare" fn set_page_directory_address(addr: u32) {
    asm!("{ PTB <- r0; }"
         "{ b r31 + 1; }");
}

extern "bare" fn get_page_directory_address() -> u32 {
    asm!("{ r0 <- PTB; }"
         "{ b r31 + 1; }");
}

extern "bare" fn enter_usermode() {
    asm!("{ r1 <- PFLAGS; r0 <- r31 + 0x10; }"
         "{ p0 <- r1 & 1; }"
         "{ p0? r0 <- r0 | 2; }"
         "{ EPC <- r0; }"
         "{ eret; }");
}

fn machine_phys_frames() -> u32 {
    // The OSOROM has 512MB of memory.
    let total_mem_bytes = 1 << 29;

    total_mem_bytes / PAGE_SIZE
}

extern "bare" fn invalidate_tlb(frame: *u8) {
    asm!("{ flush.itlb r0; }"
         "{ flush.dtlb r0; }"
         "{ b r31 + 1; }");
}

extern "bare" fn set_esp0(n: u32) {
    asm!("{ SP2 <- r0; }"
         "{ b r31 + 1; }");
}

//TODO(porting): actually implement these.
extern fn actually_switch_contexts_with_asm(new_esp: *context, old_esp: **context);
extern fn fastpath_send_switch(new_esp: *context, old_esp: **context, buffer: u32[NUM_FASTPATH_REGS]);
extern fn fastpath_recv_switch(new_esp: *context, old_esp: **context, buffer: u32[NUM_FASTPATH_REGS]);
extern fn userspace_copy(to: *u8, from: *u8, n: u32) -> i32;

